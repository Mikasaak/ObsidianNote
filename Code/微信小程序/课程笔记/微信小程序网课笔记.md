---
description: 
pubDate:
tags: 
date_created: 2024-03-31日 星期日 , 04:58:01 下午
date_modified: 2024-04-26日 星期五 , 03:18:46 下午
title: 微信小程序网课笔记
---
## 项目结构

  

![[attachments/Untitled 81.png|Untitled 81.png]]

  



## 配置文件

![[attachments/Untitled 1 5.png|Untitled 1 5.png]]

  

![[attachments/Untitled 2 6.png|Untitled 2 6.png]]

  

![[attachments/Untitled 3 6.png|Untitled 3 6.png]]

  

  

  

  

  


### 小程序的全局配置

![[attachments/Untitled 27 4.png|Untitled 27 4.png|600]]

  

![[attachments/Untitled 28 4.png|Untitled 28 4.png|400]]

#### pages
![[Pasted image 20240403214920.png]]
	
#### window

![[Pasted image 20240403215232.png|600]]

![[attachments/Untitled 29 4.png|Untitled 29 4.png]]

  

#### tabBar

![[Pasted image 20240403215500.png]]


![[attachments/Untitled 30 4.png|Untitled 30 4.png|725]]

  

![[attachments/Untitled 31 4.png|Untitled 31 4.png]]

  

  

![[attachments/Untitled 32 4.png|Untitled 32 4.png]]

  

![[attachments/Untitled 33 4.png|Untitled 33 4.png]]

  

  


### 页面配置
![[Pasted image 20240403215620.png]]

![[attachments/Untitled 34 4.png|Untitled 34 4.png]]

  

![[attachments/Untitled 35 4.png|Untitled 35 4.png]]

  




### rpx单位
![[Pasted image 20240403220423.png]]

### 全局与局部样式

![[attachments/Untitled 24 4.png|Untitled 24 4.png]]

  

  



## 小程序的样式与组件


### 基础组件
![[Pasted image 20240403233338.png]]

![[attachments/Untitled 4 6.png|Untitled 4 6.png]]

#### view 和 scrollview 组件
![[Pasted image 20240403233458.png|600]]     ![[Pasted image 20240403233515.png|675]]         

![[Pasted image 20240405164225.png]]


#### image组件
![[attachments/Untitled 5 5.png|Untitled 5 5.png]]
![[Pasted image 20240403233904.png]]

#### button 组件
![[Pasted image 20240403233847.png]]

#### text 和 rich-text组件
*里面只能写text不能放其他组件*
![[attachments/Untitled 6 5.png|Untitled 6 5.png]]

![[Pasted image 20240403233738.png]]
  


#### swiper 和swiper-item 组件
![[Pasted image 20240403233647.png]]
![[Pasted image 20240403233659.png]]
#### navigator组件
![[Pasted image 20240403221549.png]]


### 字体图标的使用

在项目中使用到的小图标，一般由公司设计师进行设计，如果如果自行设计这些图标会比较麻烦且耗费时间，这时候我们就可以使用到阿里巴巴矢量图库，设计好以后上传到阿里巴巴矢量图标库，然后方便程序员来进行使用。

![](http://8.131.91.46:6677/mina/base/公司宣传语.png)

阿里巴巴矢量图库是阿里巴巴集团推出的一个免费的矢量图标库和图标管理工具。它汇集了大量的精美图标资源，包括品牌图标和各种主题和分类的图标。用户可以在阿里巴巴矢量图库中搜索和浏览所需的图标，也可以上传和管理自己的图标资源。

小程序中的字体图标使用方式与 `Web` 开发中的使用方式是一样的。

首先我们先找到所需的图标，加入到项目库，进入项目库中生成链接。也快将字体图标库下载到本地

![](http://8.131.91.46:6677/mina/base/字体图标.jpg)

点击链接，会将生成的 `CSS` 在新的链接页面进行打开，`ctrl + s`，将该文件重命名为`.wxss` 后缀名，然后保存到项目根目录下的`static` 文件夹下。

![](http://8.131.91.46:6677/mina/base/字体图标 CSS.jpg)

在全局样式文件`app.wxss`中导入`fonts.wxss`字体图标文件，然后获取到图标类名，在项目中使用即可，应用于页面

```scss
@import "./static/fonts.wxss";
```

```html

    <view class="myTest">
      <view class="iconfont icon-tuikuan"></view>
    </view>
```

> 注意：使用字体图标可能会报错：
> 
>     [渲染层网络层错误] Failed to load font http://at.alicdn.com/t/c/font_3946178_q5oidsl5xo.woff2?t=1680795910637 net::ERR_CACHE_MISS (env: Windows,mp,1.06.2303220; lib: 2.30.4)
> 
> 该错误可忽略，详见下面这个链接：
> 
> https://developers.weixin.qq.com/miniprogram/dev/api/ui/font/wx.loadFontFace.html
> 
> **但在控制台出现错误，会影响开发调试，解决方案是：将字体图标转换成 base64 的格式**

**落地代码：**

`➡️ app.wxss`：
```scss

    // 在导入样式文件以后，必须以分号结尾，否则会出现异常
    
    @import "./iconfont/iconfont.scss";
```

`➡️ pages/index/index.wxml`：
```html
    <!-- 公司信息 -->
    <view class="info">
      <text><text class="iconfont icon-ps"></text> 同城配送</text>
      <text><text class="iconfont icon-lx"></text> 行业龙头</text>
      <text><text class="iconfont icon-time"></text> 半小时送达</text>
      <text><text class="iconfont icon-hp"></text> 100% 好评</text>
    </view>
``` 

`➡️ pages/index/index.wxss`：

```scss
    // 公司信息区域
    .info {
      display: flex;
      justify-content: space-between;
      background-color: #fff;
      padding: 20rpx 16rpx;
      border-radius: 10rpx;
      font-size: 24rpx;
    
    +   .iconfont {
    +     font-size: 24rpx;
    +   }
    }
```

12. 背景图片的使用

> 注：提供的网络地址连接：
> 
> 1. http://8.131.91.46:6677/bgimage.png
> 2. http://8.131.91.46:6677/TomAndJerry.jpg

当编写小程序的样式文件时，我们可以使用 `background-image` 属性来设置一个元素的背景图像，但是小程序的 `background-image` 不支持本地路径。

```html
    <view class="image"></view>
```

```css
    .image {
      background-image: url('../../static/微信.jpg');
    }
```

![](http://8.131.91.46:6677/mina/base/背景图片.jpg)

如图，在使用了本地资源图片以后，微信开发者工具提供的提示：

**`本地资源图片无法通过 WXSS 获取，可以使用网络图片，或者 base64，或者使用<image/>标签`**

```css
    .image {
      width: 100%;
      height: 400rpx;
      /* 本地资源图片无法通过 WXSS 获取 */
      /* background-image: url('../../static/微信.jpg'); */
    
      /* 使用网络图片 */
      /* background-image: url('http://8.131.91.46:6677/TomAndJerry.jpg'); */
    
      /* 使用 base64 格式展示图片 */
      /* base64 编码的文件很长，这个地址老师在这边进行了简写，在测试的时候，需要自己将这里转成完成的 64 编码 */
      background-image: url("data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAeAB4AAD/.....")
      background-position: center;
      background-size: cover;
    
    }
```


![[attachments/Untitled 25 4.png|Untitled 25 4.png]]
### 背景图片的使用

> 注：提供的网络地址连接：
> 
> 1. http://8.131.91.46:6677/bgimage.png
> 2. http://8.131.91.46:6677/TomAndJerry.jpg

当编写小程序的样式文件时，我们可以使用 `background-image` 属性来设置一个元素的背景图像，但是小程序的 `background-image` 不支持本地路径。
```html
    <view class="image"></view>
```

```css

    .image {
      background-image: url('../../static/微信.jpg');
    }
```

![](http://8.131.91.46:6677/mina/base/背景图片.jpg)

如图，在使用了本地资源图片以后，微信开发者工具提供的提示：

**`本地资源图片无法通过 WXSS 获取，可以使用网络图片，或者 base64，或者使用<image/>标签`**

```scss
    .image {
      width: 100%;
      height: 400rpx;
      /* 本地资源图片无法通过 WXSS 获取 */
      /* background-image: url('../../static/微信.jpg'); */
    
      /* 使用网络图片 */
      /* background-image: url('http://8.131.91.46:6677/TomAndJerry.jpg'); */
    
      /* 使用 base64 格式展示图片 */
      /* base64 编码的文件很长，这个地址老师在这边进行了简写，在测试的时候，需要自己将这里转成完成的 64 编码 */
      background-image: url("data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAeAB4AAD/.....")
      background-position: center;
      background-size: cover;
    
    }
```

<img src="http://8.131.91.46:6677/mina/base/网络图片.jpg" style="zoom:50%; border: 1px solid #ccc" />


![[attachments/Untitled 26 4.png|Untitled 26 4.png]]

  

  



## 事件处理

一个应用仅仅只有界面展示是不够的，还需要和用户做交互，例如：响应用户的点击、获取用户输入的值等等，在小程序里边，我们就通过编写 `JS` 脚本文件来处理用户的操作

#### 1. 事件绑定和事件对象

小程序中绑定事件与在网页开发中绑定事件几乎一致，只不过在小程序不能通过 `on` 的方式绑定事件，也没有 `click` 等事件，小程序中绑定事件使用 `bind` 方法，`click` 事件也需要使用 `tap` 事件来进行代替，绑定事件的方式有两种：

第一种方式：`bind:事件名`，bind 后面需要跟上冒号，冒号后面跟上事件名
```html
<button bind:tap="handler">按钮</button>
```


第二种方式：`bind事件名`，bind 后面直接跟上事件名

```html
<button bindtap="handler">按钮</button>
```

事件处理函数需要写到 `.js` 文件中，在 `.js` 文件中需要调用小程序提供的 `Page` 方法来注册小程序的页面，我们可以直接在 `Page` 方法中创建事件处理函数。例如：

```js
    // pages/home/home.js
    Page({
      // 页面的初始数据
      data: {},
    
      // 事件处理程序
      handler () {
        console.log('我被执行啦~~~')
      }
    
      // 其他 coding...
    })
```

当组件触发事件时，绑定的事件的处理函数会收到一个事件对象，用来记录事件发生时的相关信息。在触发事件时，事件处理程序会主动的给我们传入一个参数 —— `event`（事件对象）

```js
    // pages/home/home.js
    Page({
      // 页面的初始数据
      data: {},
    
      // 事件处理程序
      handler (event) {
        // console.log('我被触发了~~~')
        console.log(event)
      }
    
      // 其他 coding...
    })

```

![[attachments/Untitled 7 5.png|Untitled 7 5.png]]
![[attachments/Untitled 8 5.png|Untitled 8 5.png]]
![[attachments/Untitled 9 5.png|Untitled 9 5.png]]
#### 2. 绑定并阻止事件冒泡

事件分为冒泡事件和非冒泡事件：

1. 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。
2. 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。

使用 `bind` 绑定的事件，会触发事件冒泡，如果想阻止事件冒泡，可以使用 `catch` 来绑定事件。
```html
    <view bindtap="parentHandler">
      <!-- 使用 bind 绑定的事件，会产生事件冒泡 -->
      <!-- <button bindtap="handler">按钮</button> -->
    
      <!-- 使用 catcht 绑定的事件，会阻止事件冒泡 -->
      <button catchtap="handler">按钮</button>
    </view>
```

```js
Page({
      // 页面的初始数据
      data: {},
    
      // 事件处理程序
      handler (event) {
        console.log('我是子绑定的事件 ~~~')
      },
    
      parentHandler () {
        console.log('我是父绑定的事件 ~~~')
      }
    
      // 其他 coding...
    })
```

`WXML` 中冒泡事件列表如下表：

| 类型  | 触发条件 |
| --- | --- |
| touchstart | 手指触摸动作开始 |
| touchmove | 手指触摸后移动 |
| touchcancel | 手指触摸动作被打断，如来电提醒，弹窗 |
| touchend | 手指触摸动作结束 |
| tap | 手指触摸后马上离开 |
| longpress | 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 |
| longtap | 手指触摸后，超过350ms再离开（推荐使用 longpress 事件代替） |
| transitionend | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发 |
| animationstart | 会在一个 WXSS animation 动画开始时触发 |
| animationiteration | 会在一个 WXSS animation 一次迭代结束时触发 |
| animationend | 会在一个 WXSS animation 动画完成时触发 |
| touchforcechange | 在支持 3D Touch 的 iPhone 设备，重按时会触发 |

> 📌 **注意事项**：
> 
> ​ 除上表之外的其他组件自定义事件，如无特殊声明都是非冒泡事件​ 例如 [form](https://developers.weixin.qq.com/miniprogram/dev/component/form.html) 的`submit`事件，[input](https://developers.weixin.qq.com/miniprogram/dev/component/input.html) 的`input`事件


  
#### 3. 事件传参-data-*自定义数据

在小程序中，可以通过事件传参的方式，将数据传递给事件处理函数。常见的事件包括点击事件、输入事件等。

在组件节点中可以通过 `data-` 的方式传递一些自定义数据，传递的数据可以通过事件对象的方式进行获取

> 📌 **注意事项**：
> 
> ​ 使用 `data-` 方法传递参数的时候，多个单词由连字符 `-` 连接
> 
> ​**连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符**
> 
> ​ 例如：
> 
> ​ `data-element-type` ，最终会呈现为 `event.currentTarget.dataset.elementType `
> 
> ​ `data-elementType` ，最终会呈现为 `event.currentTarget.dataset.elementtype`

![](http://8.131.91.46:6677/mina/base/事件传参.png)

在 wxml 文件中，使用 `data-*` 属性将数据传递给事件处理函数。例如：

```html
<view bindtap="parentHandler" data-parent-id="1" data-parentName="tom">
      <!-- 如果需要进行事件传参，需要再组件上通过 data- 的方式传递数据 -->
      <!-- <button bindtap="btnHandler" data-id="1" data-name="tom">按钮</button> -->
    
      <button data-id="1" data-name="tom">按钮</button>
    </view>
```

在 js 文件中，可以通过 event.currentTarget.dataset 获取传递的数据

```js
// cate.js
    Page({
    
      // 按钮触发的事件处理函数
      btnHandler (event) {
        // currentTarget 事件绑定者，也就是指：哪个组件绑定了当前事件处理函数
        // target 事件触发者，也就是指：哪个组件触发了当前事件处理函数
        // currentTarget 和 target 都是指按钮，因为是按钮绑定的事件处理函数，同时点击按钮触发事件处理函数
        // 这时候通过谁来获取数据都可以
        console.log(event.currentTarget.dataset.id)
        console.log(event.target.dataset.name)
      },
    
    
      // view 绑定的事件处理函数
      parentHandler (event) {
        // 点击蓝色区域(不点击按钮)
        // currentTarget 事件绑定者：view
        // target 事件触发者：view
        // currentTarget 和 target 都是指 view，如果想获取 view 身上的数据，使用谁都可以
    
        // 点击按钮(不点击蓝色区域)
        // currentTarget 事件绑定者：view
        // target 事件触发者：按钮
        // 如果想获取 view 身上的数据，就必须使用 currentTarget 才可以
        // 如果想获取的是事件触发者本身的数据，就需要使用 target
        console.log(event)
    
        // 在传递参数的时候，如果自定义属性是多个单词，单词与单词直接使用中划线 - 进行连接
        // 在事件对象中会被转换为小托峰写法
        console.log(event.currentTarget.dataset.parentId)
    
        // 在传递参数的时候，如果自定义属性是多个单词，单词如果使用的是小托峰写法
        // 在事件对象中会被转为全部小写的
        console.log(event.currentTarget.dataset.parentname)
      }
    
    })
```
![[attachments/Untitled 10 5.png|Untitled 10 5.png|625]]
![[attachments/Untitled 11 4.png|Untitled 11 4.png|675]]

![[attachments/Untitled 12 4.png|Untitled 12 4.png|750]]



#### 4. 事件传参-mark 自定义数据

小程序进行事件传参的时候，除了使用 `data-*` 属性传递参数外，还可以使用 `mark` 标记传递参数

`mark`是一种自定义属性，可以在组件上添加，用于来识别具体触发事件的 target 节点。同时 `mark` 还可以用于承载一些自定义数据（类似于 `dataset` ）

`mark` 和 `dataset` 很相似，主要区别在于：

`mark` 会包含从触发事件的节点到根节点上所有的 `mark:` 属性值 (事件委托的)

`dataset` 仅包含触发事件那一个节点的 `data-` 属性值。

![](http://8.131.91.46:6677/mina/base/事件传参.png)

在 wxml 文件中，使用 `mark:自定义属性` 的方式将数据传递给事件处理函数

```html
<!-- pages/index/index.wxml -->
    
    <view bindtap="parentHandler" mark:parentid="1" mark:parentname="tom">
      <!-- 如果需要使用 mark 进行事件传参，需要使用 mark:自定义属性的方式进行参数传递 -->
      <!-- <button bindtap="btnHandler" mark:id="1" mark:name="tom">按钮</button> -->
      <button mark:id="1" mark:name="tom">按钮</button>
    </view>
```

```js
// cart.js
    Page({
    
      // 按钮绑定的事件处理函数
      btnHandler (event) {
        console.log(event.mark.id)
        console.log(event.mark.name)
      },
    
      // view 绑定的事件处理函数
      parentHandler (event) {
        // 先点击蓝色区域 (不点击按钮)
        // 通过事件对象获取的是 view 身上绑定的数据
    
        // 先点击按钮 (不点击蓝色区域)
        // 通过事件对象获取到的是 触发事件的节点 已经 父节点身上所有的 mark 数据
        console.log(event)
      }
    
    })
```

![[attachments/Untitled 13 4.png|Untitled 13 4.png]]
![[attachments/Untitled 14 4.png|Untitled 14 4.png]]

![[attachments/Untitled 15 4.png|Untitled 15 4.png]]

 
## 模板语法

### 1. 声明和绑定数据



小程序页面中使用的数据均需要在 Page() 方法的 data 对象中进行声明定义

在将数据声明好以后，需要在 WXML 中绑定数据，数据绑定最简单的方式是使用 Mustache 语法（双大括号）将变量包起来。



在 {{ }} 内部可以做一些简单的运算，支持如下几种方式：

1. 算数运算

2. 三元运算

3. 逻辑判断

4. 其他…



> 📌 **注意事项：**
>
><mark class="hltr-red"> ​	在 {{ }} 语法中，只能写表达式，不能写语句，也不能调用 js 相关的方法</mark>



**定义数据：**

```js
Page({
  // 页面的初始数据
  data: {
    num: 1
  }
    
  // coding...
}
```



**使用数据：**



`➡️ pages/index/index.wxml`

```html

<!-- 如果需要展示数据，在 wxml 中需要使用双大括号写法将变量进行包裹 -->

<!-- 展示内容 -->
<view>{{ school }}</view>
<view>{{ obj.name }}</view>

<!-- 绑定属性值，如果需要动态绑定一个变量，属性值也需要使用双大括号进行包裹 -->
<view id="{{ id }}">绑定属性值</view>

<!-- 如果属性值是布尔值，也需要使用双大括号进行包裹 -->
<checkbox checked="{{ isChecked }}" />

<!-- 算术运算 -->
<view>{{ id + 1 }}</view>
<view>{{ id - 1 }}</view>

<!-- 三元运算 -->
<view>{{ id === 1 ? '等于' : '不等于' }}</view>

<!-- 逻辑判断 -->
<view>{{ id === 1 }}</view>

<!-- 在双大括号写法内部，只能写表达式，不能写语句，也不能调用 js 的方法 -->
<!-- <view>{{ if (id === 1) {} }}</view> -->
<!-- <view>{{ for (const i = 0; i <= 10; i++) {} }}</view> -->
<view>{{ obj.name.toUpperCase() }}</view>

```



`➡️ pages/index/index.js`

```js

// index.js
Page({

  // 在小程序页面中所需要使用的数据均来自于 data 对象
  data: {
    id: 1,
    isChecked: false,
    school: '尚硅谷',
    obj: {
      name: 'tom'
    }
  }

})
     
```






![[attachments/Untitled 16 4.png|Untitled 16 4.png]]

  

简易双向绑定

![[attachments/Untitled 17 4.png|Untitled 17 4.png]]

  

  

  

  







### 2. 声明和修改数据



小程序中修改数据并不能直接进行赋值，而是要通过调用 `this.setData` 方法才能实现

将需要修改的数据以 `key:value` 的形式传给 `this.setData` 方法。

<mark class="hltr-green">`this.data.*` 可以修改数据但是无法同步更新视图</mark>

`this.setData` 方法有两个作用：

1. 更新数据
2. 驱动视图更新



```js
Page({
  // 页面的初始数据
  data: {
    num: 1
  },

  updateNum() {
    this.setData({
      // key 是需要修改的数据
      // value 是最新值
      num: this.data.num + 1
    })
  }
 
  // coding...
}
```







### 3. setData-修改对象类型数据



在实际开发中，我们经常会在 `data` 中声明对象类型的数据，小程序中通过调用 setData 方法可以修改页面的数据，包括对象类型的数据。下面是修改对象类型数据的方法：



1. 定义一个对象

   ```json
   Page({
     // 定义页面中使用的数据
     data: {
       userInfo: {
         name: 'Tom',
         age: 10,
         gender: '男'
       }
     }
   }
   ```

   

2. 修改对象中的单个属性：

   ```json
   this.setData({
     'userInfo.name': 'Jerry'
   })
   ```

   

3. 修改对象中的多个属性

   ```json
   // 修改对象中的多个属性
   this.setData({
     'userInfo.name': 'Jerry',
     'userInfo.age': 100
   })
   ```

   

4. 使用 ES6 的展开运算符

   在修改对象类型的数据时，可以使用 ES6 的展开运算符先复制对象，然后利用新值对旧值覆盖的方式修改

   ```js
   const userInfo = {
     ...this.data.userInfo,
     name: 'Jerry',
     age: 100
   }
   
   // 修改对象中的多个属性
   this.setData({
     userInfo
   })
   ```

   

5. 使用解构赋值修改对象属性

   在修改对象类型的数据时，可以使用解构赋值来修改对象属性

   ```js
   // 将 userInfo 从 data 中进行解构
   const { userInfo } = this.data
   // 产生一份新数据
   const newUserInfo = {
     ...userInfo,
     name: 'Jerry',
     age: 100
   }
   // 修改对象中的多个属性
   this.setData({
     userInfo: newUserInfo
   })
   ```

   

6. 使用 Object.assign 方法合并对象

   在修改对象类型的数据时，可以使用 Object.assign 方法将多个对象合并为一个对象

   ```js
   // 使用 Object.assign 方法将多个对象合并为一个对象
   const userInfo = Object.assign(
     this.data.userInfo, 
     { name: 'Jerry' },
     { age: 100 }
   )
   
   // 修改对象中的多个属性
   this.setData({
     userInfo
   })
   ```



7. 删除对象中的属性

   在删除对象中的属性时，不能使用 `delete` 操作符，因为小程序的数据绑定机制不支持监听 delete 操作

   ```js
   // 使用展开运算符拷贝一份数据，产生一个新对象
   const newUser = { ...this.data.userInfo }
   // 使用 delete 删除新对象中的属性
   delete newUser.age
   
   this.setData({
     // 将新的对象进行赋值
     userInfo: newUser
   })
   ```

   



> 📌 **注意事项**：
>
> 小程序的数据绑定机制只能监听到 setData 方法中修改的数据，无法监听到直接删除属性的操作，所以在删除对象属性时，需要先将对象复制一份再进行操作，然后再调用 setData 方法更新数据。







### 4. setData-修改数组类型数据



数组类型数据也是经常会使用的数据格式之一，下面是修改数组类型数据的方法：



1. 定义一个数组

   ```js
   Page({
     // 定义页面中使用的数据
     data: {
       animalList: ['Tom', 'Jerry', 'Spyke']
     }
   
     // coding...
   }
   ```

   

2. 使用数组的 concat 方法合并数组

   在修改数组类型的数据时，可以使用数组的 concat 方法来合并数组

   ```js
   // 使用 concat 方法来合并数组
   const newList = this.data.animalList.concat('Tyke')
   
   // 使用 setData 进行赋值
   this.setData({
     animalList: newList
   })
   ```

   

3. 使用数组的 push 方法新增属性

   在修改数组类型的数据时，可以使用数组的 push 方法来添加元素

   ```js
   // 使用数组的 push 方法来添加元素
   this.data.animalList.push('Tyke')
   
   // 使用 setData 进行赋值
   this.setData({
     animalList: this.data.animalList
   })
   ```

   

4. 使用 ES6 的展开运算符

   在数组类型的数据时，可以使用 ES6 的展开运算符先复制数组，然后进行合并

   ```js
   // 使用 ES6 的展开运算符先复制数组，然后进行合并
   const newList = [...this.data.animalList, 'Tyke']
   
   // 使用 setData 进行赋值
   this.setData({
     animalList: newList
   })
   ```

5. 修改数组中某个元素的值：

   利用索引的方式进行修改，但必须使用 wx:for 来进行渲染数组，否则会出现错误

   ```js
   this.setData({
     'animalList[2]': 'Tyke' 
   })
   ```

   

6. 使用数组的 filter 方法删除元素

   在修改数组类型的数据时，可以使用数组的 filter 方法来删除元素

   ```js
   // 使用数组的 filter 方法来删除元素
   const newList = this.data.animalList.filter(item => item !== 'Tom')
   
   // 使用 setData 进行赋值
   this.setData({
     animalList: newList
   })
   ```













### 5. 数据绑定-简易双向绑定



在 WXML 中，普通属性的绑定是单向的，例如：

```html
<input value="{{ num }}" />
```

如果使用 `this.setData ` 来更新 `num` ，`num` 和输入框的中显示的值都会被更新为值。但如果用户修改了输入框里的值，却不会同时改变 `data` 中的 `num` 。



如果需要在用户输入的同时也将 `data` 中的数据修改 ，需要借助简易双向绑定机制。此时可以在对应项目之前加入 `model:` 前缀即可，例如：

```html
<input model:value="{{ value }}" />
```

如果使用 `this.setData ` 来更新 `num` ，`num` 和输入框的中显示的值都会被更新为值。

如果输入框的值被改变了， `data` 的数据也会随着改变。

同时， WXML 中所有绑定了数据的位置也会被一同更新



> 📌 **注意事项：**
>
> 简易双向绑定的属性值如下限制：
>
> 1. 只能是一个单一字段的绑定，例如：错误用法：<input model:value="值为 {{value}}" />
>
> 2. 尚不能写 data 路径，也就是不支持数组和对象，例如：错误用法：<input model:value="{{ a.b }}" />



**落地代码：**

```html
<!-- 单向绑定：数据能够影响页面，但是页面更新不会影响到数据 -->
<!-- <input type="text" value="{{ value }}" /> -->

<!-- 双向绑定：数据能够影响页面，页面更新也能够影响数据 -->
<!-- 如果想实现简易双向绑定，需要再对应的属性之前添加 model: -->
<!-- <input type="text" model:value="{{ value }}" /> -->

<!-- 如果需要获取复选框的选中效果，需要给 checked 添加 model: -->
<checkbox model:checked="{{ isChecked }}" /> 是否同意该协议

<!-- 注意事项1：属性值只能是一个单一字段的绑定 -->
<!-- <input type="text" model:value="值为 {{ value }}" /> -->

<!-- 注意事项2：属性值不能写数据路径，也就是不支持对象和数组 -->
<!-- <input type="text" model:value="{{ obj.value }}" /> -->

```







### 6. 列表渲染-基本使用


![[attachments/Untitled 18 4.png|Untitled 18 4.png]]

  

![[attachments/Untitled 19 4.png|Untitled 19 4.png]]

  

  

![[attachments/Untitled 20 4.png|Untitled 20 4.png]]

  

![[attachments/Untitled 21 4.png|Untitled 21 4.png]]

  

![[attachments/Untitled 22 4.png|Untitled 22 4.png]]

  

![[attachments/Untitled 23 4.png|Untitled 23 4.png]]

  




**基本使用**

列表渲染：就是指通过循环遍历一个数组或对象，将其中的每个元素渲染到页面上

只需要在组件上使用 `wx:for` 属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件



默认数组当前项的变量名默认为 `item`

默认数组的当前项的下标变量名默认为 `index`



在使用 `wx:for` 对数组进行遍历的时候，建议加上 `wx:key` 属性，**如不提供 `wx:key`，会报一个 `warning`， 如果明确知道该列表是静态，即以后数据不会改变，或者不必关注其顺序，可以选择忽略。**



`wx:key` 的值以两种形式提供：

1. 字符串：代表需要遍历的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变
2. 保留关键字 `*this` 代表在 for 循环中的 item 本身，当 item 本身是一个唯一的字符串或者数字时可以使用



当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且 **提高列表渲染时的效率** 。





> 📌 **注意事项**：
>
> ​	在使用 `wx:for` 对数组进行遍历的时候，建议加上 `wx:key` 属性，否则控制台会报警告



**落地代码：**



```html
<!-- 如果需要进行列表渲染，需要使用 wx:for 属性 -->
<!-- 属性值需要使用双大括号进行包裹 -->
<!-- 每一项的变量名默认是 item -->
<!-- 每一项下标（索引）的变量名默认是 index -->

<!-- 如果渲染的是数组，item：数组的每一项，index：下标 -->
<!-- <view wx:for="{{ numList }}">{{ item }} - {{ index }}</view> -->

<!-- 如果渲染的是对象，item：对象属性的值，index：对象属性 -->
<!-- <view wx:for="{{ obj }}">{{ item }} - {{ index }}</view> -->

<!-- ------------------------ 关于 Key --------------------------------- -->

<!-- wx:key 提升性能 -->
<!-- wx:key 的属性值不需要使用双大括号进行包裹，直接写遍历的数组 中 item 的某个属性 -->

<!-- wx:key 属性值有两种添加形式 -->
<!-- 字符串，需要是遍历的数组 中 item 的某个属性，要求该属性是列表中唯一的字符串或者数字，不能进行动态改变 -->
<view wx:for="{{ fruitList }}" wx:key="id">{{ item.name }}</view>
<view wx:for="{{ fruitList }}" wx:key="index">{{ item.name }}</view>

<!-- 保留关键字 *this，*this 代表的是 item 本身，item 本身是唯一的字符串或者数字 -->
<view wx:for="{{ numList }}" wx:key="*this">{{ item }}</view>

```

```js
// profile.js
Page({

  data: {
    numList: [1, 2, 3],
    fruitList: [
      { id: 1, name: '🍎', price: 66 },
      { id: 2, name: '🍋', price: 77 },
      { id: 3, name: '🍅', price: 88 }
    ],
    obj: {
      name: 'tom',
      age: 10
    }
  }

})

```





### 7. 列表渲染-使用进阶



**修改默认下标和变量名：**



如果需要对默认的下标和变量名进行修改，可以使用 `wx:for-item` 和  `wx:for-index` 



1. 使用 `wx:for-item` 可以指定数组当前元素的变量名

2. 使用 `wx:for-index` 可以指定数组当前下标的变量名



```html
<view wx:for="{{ animal }}" wx:for-item="itemName" wx:for-index="i">
  {{ itemName.name }} - {{ itemName.avatar }} - {{ i }}
</view>
```



**渲染多节点结构块：**



如果需要渲染一个包含多节点的结构块，可以使用一个 `<block/>` 标签将多个组件包装起来

```html
<block wx:for="{{ animal }}">
  <view>
    <span>{{ item.name }}</span>
    <span>{{ item.avatar }}</span>
  </view>
</block>
```



**注意：** `<block/>` 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。


![[Pasted image 20240423153722.png]]






### 8. 条件渲染

![[Pasted image 20240423153819.png]]

**知识点：**



条件渲染主要用来控制页面结构的展示和隐藏，在微信小程序中实现条件渲染有两种方式：



1. 使用 `wx:if`、`wx:elif`、`wx:else` 属性组
2. 使用 `hidden` 属性



```html
<view wx:if="{{condition}}"> True </view>
```

```html
<view wx:if="{{length > 5}}"> 1 </view>
<view wx:elif="{{length > 2}}"> 2 </view>
<view wx:else> 3 </view
```

```html
<view hidden="{{condition}}"> True </view>
```



`wx:if` 和 `hidden` 二者的区别：

- `wx:if` ：当条件为 `true` 时将内容渲染出来，否则元素不会进行渲染，通过移除/新增节点的方式来实现
- `hidden` ：当条件为 `true` 时会将内容隐藏，否则元素会显示内容，通过 `display` 样式属性来实现的





**落地代码：**

```html
<!-- 使用 wx:if、wx:elif、wx:else 属性组控制元素的隐藏和控制 -->
<view wx:if="{{ num === 1 }}">num 等于 {{ num }}</view>
<view wx:elif="{{ num === 2 }}">num 等于 {{ num }}</view>
<view wx:else>大于 2</view>

<view hidden="{{ num !== 1 && num !== 2 && num !== 3 && num < 3}}">
  {{ num < 3 ? 'num 等于' + num : '大于 2' }}
</view>

<button type="primary" bindtap="updateNum">修改数据</button>

```



```js
Page({
  // 页面的初始数据
  data: {
    num: 1
  },
  
  // 更新数据
  updateNum() {
    this.setData({
      num: this.data.num + 1
    })
  }
    
  // coding...
}
```





## 生命周期

### 1. 小程序运行机制



<img src="http://8.131.91.46:6677/mina/base/运行机制.png" style="zoom:60%;  border: 1px solid #ccc" />

**冷启动与热启动：**



小程序启动可以分为两种情况，一种是冷启动，一种是热启动

冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动

热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态



**前台 以及 后台状态：**


小程序启动后，界面被展示给用户，此时小程序处于「前台」状态。

当用户「关闭」小程序时，小程序并没有真正被关闭，而是进入了「后台」状态，当用户再次进入微信并打开小程序，小程序又会重新进入「前台」状态



切后台的方式包括但不限于以下几种：

- 点击右上角胶囊按钮离开小程序
- 安卓点击返回键离开小程序
- 屏幕左侧右滑离开小程序



<img src="http://8.131.91.46:6677/mina/base/后台与前台.png" style="zoom:80%; border: 1px solid #ccc" />





**挂起：**

小程序进入「后台」状态一段时间后（5 秒），微信停止小程序 JS 线程执行，小程序进入「挂起」状态，当开发者使用了后台播放音乐、后台地理位置等能力时，小程序可以在后台持续运行，不会进入到挂起状态



**销毁：**

如果用户很久没有使用小程序，或者系统资源紧张，小程序会被销毁，即完全终止运行。

当小程序进入后台并被「挂起」后，如果很长时间（目前是 30 分钟）都未再次进入前台，小程序会被销毁

当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。







### 2. 小程序更新机制



在访问小程序时，微信会将小程序代码包缓存到本地。

开发者在发布了新的小程序版本以后，微信客户端会检查本地缓存的小程序有没有新版本，并进行小程序代码包的更新。



小程序的更新机制有两种：**启动时同步更新** 和 **启动时异步更新**



**启动时异步更新**

启动时同步更新：微信运行时，会定期检查最近使用的小程序是否有更新。如果有更新，下次小程序启动时会同步进行更新，更新到最新版本后再打开小程序。如果 用户长时间未使用小程序时，会强制同步检查版本更新



**启动时异步更新**

启动时异步更新：在启动前没有发现更新，小程序每次 冷启动 时，都会异步检查是否有更新版本。如果发现有新版本，将会异步下载新版本的代码包，**将新版本的小程序在下一次冷启动进行使用**，当前访问使用的依然是本地的旧版本代码



在启动时异步更新的情况下，如果开发者希望立刻进行版本更新，可以使用 [wx.getUpdateManager](https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.getUpdateManager.html) API 进行处理。在有新版本时提示用户重启小程序更新新版本。



```js
App({

  /**
   * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）
   */
   
  onLaunch: function () {
    const updateManager = wx.getUpdateManager()

    updateManager.onCheckForUpdate(function (res) {
      // 请求完新版本信息的回调
      console.log(res.hasUpdate)
    })

    updateManager.onUpdateReady(function () {
      wx.showModal({
        title: '更新提示',
        content: '新版本已经准备好，是否重启应用？',
        success(res) {
          if (res.confirm) {
            // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
            updateManager.applyUpdate()
          }
        }
      })
    })

    updateManager.onUpdateFailed(function () {
      // 新版本下载失败
    })
  }
  
})
```





**落地代码：**



```js
// app.js
App({
  
  // onLaunch 是小程序的钩子函数，这个钩子函数在冷启动时肯定会执行到
  // 当小程序冷启动时，会自动微信后台请求新版本的信息，如果有新版本，会立即进行下载
  onLaunch () {
    // 使用 wx.getUpdateManager 方法监听下载的状态
    const updateManager = wx.getUpdateManager()

    // 当下载完成新版本以后，会触发 onUpdateReady 回调函数
    updateManager.onUpdateReady(function () {
      // 在回调函数中给用户提示，
      wx.showModal({
        title: '更新提示',
        content: '新版本已经准备好，是否重启应用？',
        success(res) {
          if (res.confirm) {
            // 强制当前小程序使用新版本并且会重启当前小程序
            updateManager.applyUpdate()
          }
        }
      })
    })
  }

})

```







### 3. 生命周期介绍
![[Pasted image 20240423160202.png]]


应用生命周期是指应用程序进程**从创建到消亡的整个过程**

小程序的生命周期指的是 小程序从**启动到销毁的整个过程**



在打开一个小程序应用的时候都需要经历一系列的初始化步骤，比如页面是否加载完成、页面是否初次渲染完成等等。

在此过程中，小程序也会运行被称为生命周期钩子的函数，这些函数由小程序框架本身提供，被称为生命周期函数，生命周期函数会按照顺序依次自动触发调用。帮助程序员在特定的时机执行特定的操作，辅助程序员完成一些比较复杂的逻辑。让开发者有机会在特定阶段运行自己的代码。



小程序的生命周期分类三类：应用级别、页面级别和组件级别 3 种类型，我们先学习应用级别和页面级别的生命周期



<img src="http://8.131.91.46:6677/mina/base/小程序生命周期介绍.png" style="zoom:80%;" />







### 4. 应用级别生命周期



**知识点：**



应用生命周期通常是指一个小程序从 启动 → 运行 → 销毁的整个过程

应用生命周期伴随着一些函数，我们称为 应用生命周期函数，应用生命周期函数需要 在 app.js 文件的 App() 方法中定义

当整个小程序应用运行到某个时机的时候，我们需要做一些事情。例如：当小程序启动成功之后，我们要获取小程序的一些信息，就可以在小程序启动成功时的钩子函数中写代码获取我们想要的信息。

|                           生命周期                           | 必填 | 说明                                |
| :----------------------------------------------------------: | :--: | :---------------------------------- |
| [onLaunch](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object) |  否  | 监听小程序初始化，全局只会执行 1 次 |
| [onShow](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onShow-Object-object) |  否  | 监听小程序启动或切前台              |
| [onHide](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onHide) |  否  | 监听小程序切后台                    |



<img src="http://8.131.91.46:6677/mina/base/应用生命周期.png" style="zoom:90%; border: 1px solid #ccc" />



> 📌 **注意事项：**
>
> 1. 从小程序生命周期的角度来看，我们一般讲的「启动」专指冷启动，热启动一般被称为后台切前台。
>
> 2. **App() 必须在 `app.js` 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。**



小程序启动后，后台会首先完成小程序的初始化，该过程只会触发一次；之后会完成显示的工作，用户可以操作小程序从前台进入后台以及从后台回复到前台显示；小程序在后台运行一段时间，当系统资源不足时会被注销。





**落地代码：**



`➡️ app.js`

```js
App({
  /**
   * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）
   */
  onLaunch: function () {
    // 监听小程序初始化
    console.log('onLaunch: 当小程序初始化完成时，会触发 onLaunch')
  },

  /**
   * 当小程序启动，或从后台进入前台显示，会触发 onShow
   */
  onShow: function (options) {
    // 监听小程序的显示
    console.log('onShow: 当小程序启动，或从后台进入前台显示')
  },

  /**
   * 当小程序从前台进入后台，会触发 onHide
   */
  onHide: function () {
    // 监听小程序的隐藏
    console.log('onHide: 小程序从前台进入后台')
  }
})

```







### 5. 页面级别生命周期



**知识点：**



页面生命周期就是指小程序页面从 加载 → 运行 → 销毁的整个过程



当某个页面运行到某个时机的时候，我们需要做一些事情，例如: 当某个页面加载完毕之后，需要发请求获取当前页面所需的数据，就可以在对应的页面加载完成后的钩子函数中执行发送请求的代码。



小程序中的一个页面都需要在对应页面的 `.js` 文件中调用 `Page()` 方法来注册。`Page()` 接受一个 `Object` 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。



|                           生命周期                           | 必填 |                             说明                             |
| :----------------------------------------------------------: | :--: | :----------------------------------------------------------: |
| [onLoad](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query) |  否  |            页面加载时触发 (一个页面只会调用一次)             |
| [onShow](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onShow) |  否  |           页面显示时触发，页面显示/切入前台时触发            |
| [onReady](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onReady) |  否  | 页面初次渲染完成时触发(一个页面只会调用一次)<br />代表页面已经准备妥当，可以和视图层进行交互 |
| [onHide](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onHide) |  否  |                   页面隐藏/切入后台时触发                    |
| [onUnload](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onUnload) |  否  |                        页面卸载时触发                        |



<img src="http://8.131.91.46:6677/mina/base/页面生命周期函数.png" style="zoom:80%; border: 1px solid #ccc" />





**落地代码：**

```js
// pages/home/home.js
Page({
   
  // coding...
    
  // 生命周期函数--监听页面加载
  onLoad: function (options) {
    console.log('页面加载完毕')
  },

  // 生命周期函数--监听页面显示
  onShow: function () {
    console.log('监听页面显示，此时页面处于显示状态')
  },

  // 生命周期函数--监听页面初次渲染完成
  onReady: function () {
    console.log('页面初次渲染已经完成')
  },

  // 生命周期函数--监听页面隐藏
  onHide: function () {
    console.log('当前页面处于隐藏状态')
  },

  // 生命周期函数--监听页面卸载
  onUnload: function () {
    console.log('页面卸载时触发')
  }
})

```







### 6. 生命周期两个细节补充说明



1. tabBar 页面之间相互切换，页面不会被销毁

2. 点击左上角，返回上一个页面，会销毁当前页面(被打开页面)

   

<img src="http://8.131.91.46:6677/mina/base/声明周期两个细节.png" style="zoom:50%;" />



### 7. 黑马网课的生命周期


![[attachments/Untitled 59 2.png|Untitled 59 2.png]]

  

![[attachments/Untitled 60 2.png|Untitled 60 2.png]]

![[attachments/Untitled 61 2.png|Untitled 61 2.png]]

  

  

![[attachments/Untitled 62 2.png|Untitled 62 2.png]]

  

![[attachments/Untitled 63 2.png|Untitled 63 2.png]]

  
## 微信原生 API


### 1. API 基础



小程序开发框架提供丰富的微信原生 `API`，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等，几乎所有小程序的 `API` 都挂载在 `wx` 对象底下，例如：`wx.chooseMedia()`、`wx.request()`, `wx` 对象实际上就是小程序的宿主环境微信所提供的全局对象



通常，在小程序 API 有以下几种类型：

1. 事件监听 API：约定以 `on` 开头 API 用来监听某个事件是否触发，例如：`wx.onThemeChange()`
2. 同步 API：约定以 `Sync` 结尾的 API 都是同步 API，例如：`wx.setStorageSync()`
3. 异步 API：大多数 API 都是异步 API，例如：`wx.setStorage()`



<img src="http://8.131.91.46:6677/mina/base/小程序 API 类型.png" style="zoom:80%; border: 1px solid #ccc" />



异步 API 支持 callback & Promise 两种调用方式：

1. 当接口参数 Object 对象中不包含 success/fail/complete 时将默认返回 Promise

2. 部分接口如 request, uploadFile 本身就有返回值，因此不支持 Promise 风格的调用方式，它们的 promisify 需要开发者自行封装。





[小程序 API 介绍](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html)

[微信小程序 API 文档](https://developers.weixin.qq.com/miniprogram/dev/api/)







### 2. 网络请求



**知识点：**



在微信小程序中，如果需要发起 HTTPS 网络请求需要使用：`wx.request()`，语法如下：



```js
wx.request({
  // 接口地址，仅为示例，并非真实的接口地址
  url: 'example.php',
  // 请求的参数
  data: { x: '' },
  // 请求方式
  method: 'GET|POST|PUT|DELETE',
  success (res) {
    console.log(res.data)
  },
  fail(err) {
    console.log(err)
  }
})
```



<font color="red">**注意：wx.request() 请求的域名需要在小程序管理平台进行配置，如果小程序正式版使用wx.request请求未配置的域名，在控制台会有相应的报错。**</font>



<img src="http://8.131.91.46:6677/mina/base/038-网络请求错误.png" style="zoom:80%;" />



这时候就需要在小程序管理后台进行设置请求的域名，打开微信公众后台：点击左侧 开发 → 开发管理 → 开发设置 → 服务器域名。**域名只支持 `https` 而且要求已备案**



<img src="http://8.131.91.46:6677/mina/base/39-开发设置.png" style="zoom:47.5%; border: 1px solid #ccc" />

<img src="http://8.131.91.46:6677/mina/base/40-配置服务器域名.png" style="zoom:49.4%; border: 1px solid #ccc" />



但一般我们在开发阶段时，处于开发阶段的服务器接口可能还没部署到对应的域名下，经常会通过另一个域名来进行开发调试，考虑到这一点，为了方便开发者进行开发调试，开发者工具、小程序的开发版和小程序的体验版在某些情况下允许 `wx.request` 请求任意域名 (只适用于开发环境，只能在小程序开发者工具中生效)，在开发工具中设置步骤如下：



将 **不校验合法域名、web-view (业务域名)、TLS版本以及HTTPS证书** 勾选上：

​      <img src="http://8.131.91.46:6677/mina/base/41-不校验合法域名.png" style="zoom:61%;" />       <img src="http://8.131.91.46:6677/mina/base/41-不校验合法域名-1.png" style="zoom:50.25%;" /> 



> 📌 **注意事项：**
>
> ​	这两种方式只适用于开发者工具、小程序的开发版和小程序的体验版
>
> ​	项目上线前必须在小程序管理平台进行合法域名的配置



**落地代码：**



```js
Page({
  // 页面的初始数据
  data: {},

  // 获取数据
  getPostInfo() {
    wx.request({
      url: 'https://jsonplaceholder.typicode.com/posts/1',
      method: 'GET',
      success(res) {
        console.log(res)
      },
      fail(err) {
        console.log(err)
      }
    })
  },
    
  // coding...
}
```









### 3. 界面交互

![[Pasted image 20240424150753.png]]

小程序还提供了一些用于界面交互的 API，如消息提示框、模态对话框、 loading 提示框等等



#### 3.1 loading 提示框



**知识点：**



小程序提供了一些用于界面交互的 API，例如： loading 提示框、消息提示框、模态对话框等 API。

<img src="http://8.131.91.46:6677/mina/base/loading 提示框.gif" style="zoom:80%; border: 1px solid #ccc" />



loading 提示框常配合网络请求来使用，用于增加用户体验，对应的 API 有两个：

1. `wx.showLoading` 显示加载提示框
2. `wx.hideLoading` 隐藏加载提示框



语法如下：

```js
wx.showLoading({
  title: '提示内容', // 提示的内容
  mask: true, // 是否显示透明蒙层，防止触摸穿透
  success() {}, // 接口调用成功的回调函数
  fail() {} // 接口调用失败的回调函数
})
```





官方文档：

[wx.showLoading 官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showLoading.html)

[wx.hideLoading 官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.hideLoading.html)





**落地代码：**

```js
Page({

  data: {
    list: []
  },

  // 获取数据
  getData () {

+     // 显示 loading 提示框
+     wx.showLoading({
+       // 用来显示提示的内容
+       // 提示的内容不会自动换行，如果提示的内容比较多，因为在同一行展示
+       // 多出来的内容就会被隐藏
+       title: '数据加载中...',
+       // 是否展示透明蒙层，防止触摸穿透
+       mask: true
+     })

    // 如果需要发起网络请求，需要使用 wx.request API
    wx.request({
      // 接口地址
      url: 'https://gmall-prod.atguigu.cn/mall-api/index/findBanner',
      // 请求方式
      method: 'GET',
      // 请求参数
      data: {},
      // 请求头
      header: {},
      // API 调用成功以后，执行的回调
      success: (res) => {
        // console.log(res)
        if (res.data.code === 200) {
          this.setData({
            list: res.data.data
          })
        }
      },
      // API 调用失败以后，执行的回调
      fail: (err) => {
        console.log(err)
      },
      // API 不管调用成功还是失败以后，执行的回调
      complete: (res) => {
        // console.log(res)

+         // 关掉 loading 提示框
+         // hideLoading 和 showLoading 必须结合、配对使用才可以
+         wx.hideLoading()
      }
    })

  }

})

```





#### 3.2 模态对话框以及消息提示框

![[Pasted image 20240424151151.png]]


**知识点：**



`wx.showToast()`：消息提示框用来根据用户的某些操作来告知操作的结果，如退出成功给用户提示，提示删除成功等，语法如下：



```js
wx.showToast({
  title: '标题', // 提示的内容
  duration: 2000, // 提示的延迟时间
  mask: true, // 是否显示透明蒙层，防止触摸穿透
  icon: 'success', // 	图标
  success() {}, // 接口调用成功的回调函数
  fail() {} // 接口调用失败的回调函数
})
```



`wx.showModal()` 模态对话框也是在项目中频繁使用的一个小程序 `API`，通常用于向用户询问是否执行一些操作，例如：点击退出登录，显示模态对话框，询问用户是否真的需要退出等等

```js
wx.showModal({
  title: '提示', // 提示的标题
  content: '您确定执行该操作吗？', // 提示的内容
  confirmColor: '#f3514f',
  // 接口调用结束的回调函数（调用成功、失败都会执行）
  success({ confirm }) {
    confirm && consle.log('点击了确定')
  }
})
```





官方文档：

[wx.showToast 官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html)

[wx.showModal 官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showModal.html)



<img src="http://8.131.91.46:6677/mina/base/模态对话框以及消息提示框.gif" style="zoom:80%; border: 1px solid #ccc" />





**落地代码：**



```js
Page({
  // coding...
  
  // 删除商品
  async delHandler () {

    // showModal 显示模态对话框
    const { confirm } = await wx.showModal({
      title: '提示',
      content: '是否删除该商品 ?'
    })

    if (confirm) {
      // showToast 消息提示框
      wx.showToast({
        title: '删除成功',
        icon: 'none',
        duration: 2000
      })
    } else {
      wx.showToast({
        title: '取消删除',
        icon: 'error',
        duration: 2000
      })
    }

  }
   
  // coding...

})
```









### 4. 本地存储

![[Pasted image 20240424152530.png]]

小程序中也能够像网页一样支持本地数据缓存，本地数据缓存是小程序存储在当前设备上硬盘上的数据，本地数据缓存有非常多的用途，我们可以利用本地数据缓存来存储用户在小程序上产生的操作，在用户关闭小程序重新打开时可以恢复之前的状态。我们还可以利用本地缓存一些服务端非实时的数据提高小程序获取数据的速度，在特定的场景下可以提高页面的渲染速度，减少用户的等待时间。其包含以下 8个主要的 API



| 同步 API               | 异步 API              | 作用                                |
| ---------------------- | --------------------- | ----------------------------------- |
| `wx.setStorageSync`    | `wx.setStorage`       | 将数据存储在本地缓存中指定的 key 中 |
| `wx.getStorageSync`    | `wx.getStorage`       | 从本地缓存中同步获取指定 key 的内容 |
| `wx.removeStorageSync` | `wx.removeStorage`    | 从本地缓存中移除指定 key            |
| `wx.clearStorageSync`  | `wx.clearStorageSync` | 清理本地数据缓存                    |



<img src="http://8.131.91.46:6677/mina/base/本地存储.png" style="zoom:80%; border: 1px solid #ccc" />



异步方式的 `API`，在调用的时候都需要传入对象类型的参数

同步方式执行的 API 在使用时简洁比较好，缺点是同步会阻塞程序执行，执行效率上相较异步版本要差一些。



> 📌 **注意事项**：
>
> 1. 对象类型的数据，可以直接进行存储，无需使用 `JSON.stringify` 转换
> 2. 对象类型的数据存的时候没有使用转换，因此获取的时候也不需要使用 `JSON.parse` 转换



**落地代码：**

```html
<button type="primary" bindtap="handler" size="mini" plain bindtap="setData">
  存储数据
</button>

<button type="primary" bindtap="handler" size="mini" plain bindtap="getData">
  获取数据
</button>

<button type="warn" bindtap="handler" size="mini" plain bindtap="delData">
  删除数据
</button>

<button type="warn" bindtap="handler" size="mini" plain bindtap="clearData">
  移除数据
</button>
```



```js
Page({

  // 将数据存储到本地
  setStorage () {

    // 第一个参数：本地存储中指定的 key
    // 第二个参数：需要存储的数据
    // wx.setStorageSync('num', 1)

    // 在小程序中
    // 如果存储的是对象类型数据，不需要使用 JSON.stringify 和 JSON.parse 进行转换
    // 直接进行存储和获取即可
    // wx.setStorageSync('obj', { name: 'tom', age: 10 })

    // ------------------- 异步 API -------------------
 
    wx.setStorage({
      key: 'num',
      data: 1
    })

    wx.setStorage({
      key: 'obj',
      data: { name: 'jerry', age: 18 }
    })

  },

  // 获取本地存储的数据
  async getStorage () {

    // 从本地存储的数据中获取指定 key 的数据、内容
    // const num = wx.getStorageSync('num')
    // const obj = wx.getStorageSync('obj')

    // console.log(num)
    // console.log(obj)

    // ------------------- 异步 API -------------------

    const { data } = await wx.getStorage({
      key: 'obj'
    })

    console.log(data)

  },

  // 删除本地存储的数据
  removeStorage () {

    // 从本地移除指定 key 的数据、内容
    // wx.removeStorageSync('num')

    // ------------------- 异步 API -------------------

    wx.removeStorage({
      key: 'num'
    })

  },

  // 清空本地存储的全部数据
  clearStorage () {
    // wx.clearStorageSync()
      
    // ------------------- 异步 API -------------------

    wx.clearStorage()
  },

})

```





### 5. 路由与通信

[[微信小程序网课笔记#导航#微信文档描述]]

**知识点：**



在小程序中实现页面的跳转，有两种方式：

1. 声明式导航：`navigator` 组件
2. 编程式导航：使用小程序提供的 `API`
   - `wx.navigateTo()`：保留当前页面，跳转到应用内的某个页面，但是不能跳到 tabbar 页面
   - `wx.redirectTo()`：关闭当前页面（若当前界面是tabBar也会销毁），跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面
   - `wx.switchTab()`：跳转到 tabBar 页面，路径后不能带参数
   - `wx.reLaunch()` ：关闭所有页面，打开到应用中的某个页面<mark class="hltr-green">（tabBar也会卸载）</mark>
   - `wx.navigateBack()`：关闭当前页面，返回上一页面或多级页面
3. **路径后可以带参数，参数需要在跳转到的页面的 `onLoad` 钩子函数中通过形参进行接收**
   - 参数与路径之间使用 `?` 分隔
   - 参数键与参数值用 = 相连
   - 不同参数用 `&` 分隔
   - 例如 `path?key=value&key2=value2`



![[Pasted image 20240424201541.png]]



**落地代码：**

```js
Page({


  navigateTo() {

    // 保留当前页面，跳转到应用中其他页面，不能跳转到 tabBar 页面
    wx.navigateTo({
      url: '/pages/list/list?id=1&name=tom'
      // url: '/pages/cate/cate'
    })

  },

  redirectTo() {

    // 关闭(销毁)当前页面，跳转到应用中其他页面，不能跳转到 tabBar 页面
    wx.redirectTo({
      url: '/pages/list/list?id=1&name=tom'
      // url: '/pages/cate/cate'
    })

  },

  switchTab() {

    // 跳转到 tabBar 页面，不能跳转到 非 tabBar 页面，路径后面不能传递参数
    wx.switchTab({
      // url: '/pages/list/list'
      url: '/pages/cate/cate?id=1&name=tom'
    })

  },

  reLaunch() {

    // 关闭所有的页面，然后跳转到应用中某一个页面
    wx.reLaunch({
      url: '/pages/list/list?id=1&name=tom'
      // url: '/pages/cate/cate?id=1&name=tom'
    })

  }

})
```



```js
// list.js
Page({

  navigateBack() {

    // 关闭当前页面，返回上一页或者返回多级页面
    // 默认返回上一页
    wx.navigateBack({
      delta: 1
    })

  },

  onLoad(options) {
    console.log(options)
  }

})

```





















### 6. 事件监听-上拉加载更多



上拉加载是小程序中常见的一种加载方式，当用户滑动页面到底部时，会自动加载更多的内容，以便用户继续浏览



小程序中实现上拉加载的方式：

1.在 app.json 或者 page.json 中配置距离页面底部距离： onReachBottomDistance；默认 50px

2.在 页面.js 中定义 onReachBottom 事件监听用户上拉加载



​              <img src="C:\Users\15778\Desktop\01-小程序课程笔记\01-小程序基础\images\上拉加载更多.gif" style="zoom:70%;" />       <img src="http://8.131.91.46:6677/mina/base/上拉加载更多案例.gif" style="zoom:80%;" />





**落地代码：**



```html
<view wx:for="{{ numList }}" wx:key="*this">{{ item }}</view>
```



```scss
/* pages/market/market.wxss */

view {
  height: 400rpx;
  display: flex;
  align-items: center;
  justify-content: center;
}

view:nth-child(odd) {
  background-color: lightskyblue;
}

view:nth-child(even) {
  background-color: lightsalmon;
}
```



```js
Page({

  data: {
    numList: [1, 2, 3]
  },

  // 监听用户上拉加载
  onReachBottom() {
    // console.log('监听用户上拉加载')
    // 产品需求：
    // 当用户上拉，需要数字进行累加

    // 当用户上拉加载时，需要对数字进行累加，每次累加 3 个数字
    // 目前是 [1, 2, 3]，[1, 2, 3, 4, 5, 6]
    // 怎么进行追加 ？
    // 获取目前数组中最后一项 n，n + 1, n + 2, n + 3

    wx.showLoading({
      title: '数据加载中...'
    })

    setTimeout(() => {
      // 获取数组的最后一项
      const lastNum = this.data.numList[this.data.numList.length - 1]
      // 定义需要追加的元素
      const newArr = [lastNum + 1, lastNum + 2, lastNum + 3]

      this.setData({
        numList: [...this.data.numList, ...newArr]
      })

      wx.hideLoading()
    }, 1500)

  }

})

```









### 7. 事件监听-下拉刷新



下拉刷新是小程序中常见的一种刷新方式，当用户下拉页面时，页面会自动刷新，以便用户获取最新的内容。



小程序中实现上拉加载更多的方式：

1.在 app.json 或者 page.json 中开启允许下拉，同时可以配置 窗口、loading 样式等 

2.在 页面.js 中定义 onPullDownRefresh 事件监听用户下拉刷新



​                  <img src="http://8.131.91.46:6677/mina/base/下拉刷新.gif" style="zoom:67%;" />      <img src="http://8.131.91.46:6677/mina/base/下拉刷新案例.gif" style="zoom:70%;" />     





**落地代码：**



```html
<view wx:for="{{ numList }}" wx:key="*this">{{ item }}</view>
```



```scss
/* pages/market/market.wxss */

view {
  height: 400rpx;
  display: flex;
  align-items: center;
  justify-content: center;
}

view:nth-child(odd) {
  background-color: lightskyblue;
}

view:nth-child(even) {
  background-color: lightsalmon;
}
```



```js
Page({

  data: {
    numList: [1, 2, 3]
  },

  // 监听用户上拉加载
  onReachBottom() {
    
     // coding...

  },

  // 监听用户下拉刷新
  onPullDownRefresh () {
    // console.log('监听用户下拉刷新')

    // 产品需求：
    // 当用户上拉加载更多以后，如果用户进行了下拉刷新
    // 需要将数据进行重置
    this.setData({
      numList: [1, 2, 3]
    })

    // 在下拉刷新以后，loading 效果有可能不会回弹回去
    if (this.data.numList.length === 3) {
      wx.stopPullDownRefresh()
    }
  }

})

```













### 8. 增强 scroll-view



#### 8.1 scroll-view 上拉加载



**知识点**：



bindscrolltolower：滚动到底部/右边时触发

lower-threshold：距底部/右边多远时，触发 scrolltolower 事件

enable-back-to-top：**让滚动条返回顶部**，iOS 点击顶部状态栏、安卓双击标题栏时，只支持竖向



<img src="http://8.131.91.46:6677/mina/base/scroll-上拉加载更多.gif" style="zoom:80%; border: 1px solid #ccc" />



**落地代码：**



```html
<scroll-view
  class="scroll-y"
  scroll-y
  lower-threshold="100"
  bindscrolltolower="getMore"
  enable-back-to-top
>

  <view wx:for="{{ arr }}" wx:key="*this">{{ item }}</view>

</scroll-view>
```



```js
// index.js
Page({

  data: {
    arr: [1, 2, 3]
  },

  // 上拉加载更多
  getMore() {

    wx.showLoading({
      title: '数据正在加载中...'
    })

    setTimeout(() => {

      // 记录当前数组的最后一个元素
      let lastNum = this.data.arr[this.data.arr.length - 1]
      // 最后一个元素加 1
      lastNum++
      // 每次向数组中新增三项
      const newArr = [lastNum, lastNum + 1, lastNum + 2]

      this.setData({
        arr: [...this.data.arr, ...newArr]
      })

     // 数据返回，隐藏 Loading
     wx.hideLoading()

     wx.showToast({
       title: '数字请求完毕，上滑继续浏览',
       icon: 'none'
     })

    }, 1000)

  }
})
```







#### 8.2 scroll-view 下拉刷新



**知识点：**



refresher-enabled：开启自定义下拉刷新

refresher-default-style自定义下拉刷新默认样式支持设置 `black | white | none`， none 表示不使用默认样式

refresher-background：自定义下拉刷新区域背景颜色

bindrefresherrefresh：自定义下拉刷新状态回调

refresher-triggered：设置当前下拉刷新状态，(true 下拉刷新被触发，false 表示下拉刷新未被触发，**用来关闭下拉效果**)



<img src="http://8.131.91.46:6677/mina/base/scroll-下拉刷新.gif" style="zoom:80%; border: 1px solid #ccc" />



**落地代码：**



```html
<scroll-view
  class="scroll-y"
  scroll-y
  lower-threshold="100"
  bindscrolltolower="getMore"
  enable-back-to-top
             
  refresher-enabled
  refresher-default-style="black"
  refresher-background="#f7f7f8"
  refresher-triggered
  bindrefresherrefresh="onrefresh"
  refresher-triggered="{{ triggered }}"
>

  <view wx:for="{{ arr }}" wx:key="*this">{{ item }}</view>

</scroll-view>
```



```js
// index.js
Page({

  data: {
    triggered: false, // 控制 scroll-view 下拉刷新效果
    arr: [1, 2, 3]
  },

  // scroll-view 下拉刷新回调函数
  onrefresh() {

    wx.showLoading({
      title: '数据正在加载中...'
    })

    // 定时器模拟网络请求，1 秒后数据返回
    setTimeout(() => {

      // 重置数据
      this.setData({
        arr: [1, 2, 3]
      })

      // 数据返回，隐藏 Loading
      wx.hideLoading()

      wx.showToast({
        title: '下拉刷新完成，数据已重置...',
        icon: 'none'
      })

      // 数据返回，关闭 scroll-view 下拉刷新效果
      this.setData({
        triggered: false
      })

    }, 1000)
  }
})
```







#### 8.3 增强 scroll-view 完整代码



```html
<scroll-view
  scroll-y
  class="scroll-y"

  lower-threshold="100"
  bindscrolltolower="getMore"
  enable-back-to-top

  refresher-enabled
  refresher-default-style="black"
  refresher-background="#f7f7f8"
  bindrefresherrefresh="refreshHandler"
  refresher-triggered="{{isTriggered}}"
>
  
  <view wx:for="{{ numList }}" wx:key="*this">{{ item }}</view>

</scroll-view>
```



```scss
/* pages/index/index.wxss */

.scroll-y {
  height: 100vh;
  background-color: #efefef;
}

view {
  height: 500rpx;
  display: flex;
  align-items: center;
  justify-content: center;
}

view:nth-child(odd) {
  background-color: skyblue;
} 

view:nth-child(even) {
  background-color: lightsalmon;
}

```



```js

Page({

  data: {
    numList: [1, 2, 3],
    isTriggered: false
  },

  // 下拉刷新
  refreshHandler () {

    wx.showToast({
      title: '下拉刷新...'
    })
    
    setTimeout(() => {
      this.setData({
        numList: [1, 2, 3],
        isTriggered: false
      })
    }, 2000)

  },


  // scroll-view 上拉加载更多事件的事件处理函数
  getMore () {

    
    wx.showLoading({
      title: '数据加载中...'
    })

    setTimeout(() => {
      // 获取数组的最后一项
      const lastNum = this.data.numList[this.data.numList.length - 1]
      // 定义需要追加的元素
      const newArr = [lastNum + 1, lastNum + 2, lastNum + 3]

      this.setData({
        numList: [...this.data.numList, ...newArr]
      })

      wx.hideLoading()
    }, 1500)


  }

})

```


## 自定义组件



### 1. 创建-注册-使用组件



**组件介绍**



小程序目前已经支持组件化开发，可以将页面中的功能模块抽取成自定义组件，以便在不同的页面中重复使用；

也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。



开发中常见的组件有两种:

1. 公共组件：将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用
2. 页面组件：将复杂的页面拆分成多个低耦合的模块，有助于代码维护



如果是公共组件，建议将其放在小程序的目录下的 `components` 文件夹中

如果是页面组件，建议将其放在小程序对应页面目录下，当然你也可以放到页面的 `components` 文件夹中

同时建议：**一个组件一个文件夹，文件夹名称和组件名称保持一致**



> 📌 **注意事项**：
>
> 1.  自定义组件的需要在 `json` 文件中需要配置 `component` 字段设为 `true` 
> 2.  自定义组件通过 `Component` 构造器进行构建，在构造器中可以指定组件的属性、数据、方法等





**创建自定义组件：**



创建组件的步骤很简单，以公共组件为例，创建的步骤如下：

1. 在小程序的目录下新建 `components` 文件夹
2. 在 `components` 文件夹上，点击右键，选择`新建文件夹 `，然后输入文件夹名称，我们建议文件夹的名称和组件的名称保持一致，这样方便后期对组件进行维护。我们这里新的的组件名称叫做：`custom-checkbox`

3. 在新建的组件文件夹上，点击右键，选择`新建 Component`，然后输入组件的名称，组件的名称建议和文件夹保持一致

4. 此时就已经创建了一个功能组件![[Pasted image 20240424211206.png]]




**使用自定义组件**



开发中常见的组件主要分为 公共组件 和 页面组件 两种，因此注册组件的方式也分为两种：

1. 全局注册：在 `app.json` 文件中配置 `usingComponents` 节点进行引用声明，注册后可在任意组件使用
2. 局部注册：在页面的 `json` 文件中配置 `usingComponents` 节点进行引用声明，只可在当前页面使用



![[Pasted image 20240424211643.png]]



在配置 `usingComponents` 节点进行引用声明时，需要提供自定义组件的标签名和对应的自定义组件文件路径，语法如下：



```json
{
  "usingComponents": {
    "自定义组件的标签名": "自定义组件文件路径"
  }
}
```



这样，在页面的 `wxml` 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。



```json
{
  "usingComponents": {
    "custom-checkbox": "/components/custom-checkbox/custom-checkbox"
  }
}
```

```html
<!--pages/index/index.wxml-->

<view>
  <!-- 将导入的自定义组件当成标签使用 -->
  <custom-checkbox
                   />
</view>

```







### 2. 自定义组件-数据和方法



在组件的 .js 中，需要调用 `Component` 方法创建自定义组件，`Component` 中有以下两个属性：



`data` 数据：组件的内部数据

`methods` 方法：在组件中事件处理程序需要写到 `methods` 中才可以



<img src="http://8.131.91.46:6677/mina/base/自定义组件案例.png" style="zoom:80%; border: 1px solid #ccc" />



**落地代码：**



`➡️ components/custom-checkbox/custom-checkbox.wxml`

```html
<!--components/custom-checkbox/custom-checkbox.wxml-->
<!-- <text>我是自定义组件</text> -->

<view class="custom-checkbox-container">
  <view class="custom-checkbox-box">
    <checkbox checked="{{ isChecked }}" bindtap="updateChecked" />
  </view>
</view>
```



`➡️ components/custom-checkbox/custom-checkbox.wxss`

```css
/* components/custom-checkbox/custom-checkbox.wxss */

.custom-checkbox-container {
  display: inline-block;
}
```



`➡️ components/custom-checkbox/custom-checkbox.js`

```js
Component({

  /**
   * 组件的初始数据：用来定义当前组件内部所需要使用的数据
   */
  data: {
    isChecked: false
  },

  /**
   * 组件的方法列表：在组件中，所有的事件处理程序都需要写到 methods 方法中
   */
  methods: {
    
    // 更新复选框的状态
    updateChecked () {

      this.setData({
        isChecked: !this.data.isChecked
      })

      console.log(this.data.isChecked)
    }

  }
  
})
```



`➡️ app.json`

```json
{
  "usingComponents": {
    "custom-checkbox": "./components/custom-checkbox/custom-checkbox"
  }
}
```





`➡️ index.wxml`

```html
<custom-checkbox />

<view class="line"></view>

<custom-checkbox />

```







### 3. 自定义组件-属性

![[Pasted image 20240425143517.png]]

属性 Properties 是指组件的对外属性，主要用来接收组件使用者传递给组件内部的数据，和 data 一同用于组件的模板渲染



> 📌 注意事项：
>
> 1. 设置属性类型需要使用 type 属性，属性类型是必填项，value 属性为默认值
> 2. 属性类型可以为 String、Number、Boolean、Object、Array ，也可以为 null 表示不限制类型



<img src="http://8.131.91.46:6677/mina/base/自定义组件案例.png" style="zoom:80%; border: 1px solid #ccc" />





**落地代码：**



`➡️ index.wxml`

```html
<!-- label 文本显示的内容 -->
<!-- position 控制文本显示的位置 -->

<custom-checkbox label="我已阅读并同意 用户协议 和 隐私协议" position="right" />

<view class="line"></view>

<custom-checkbox label="匿名提交" position="left" />

```





`➡️ components/custom-checkbox/custom-checkbox.wxml`

```html
<!--components/custom-checkbox/custom-checkbox.wxml-->
<!-- <text>我是自定义组件</text> -->

<view class="custom-checkbox-container">
+   <view class="custom-checkbox-box {{ position === 'right' ? 'right' : 'left' }}">
+     <checkbox class="custom-checkbox" checked="{{ isChecked }}" bindtap="updateChecked" />
+ 
+     <view>
+       <text>{{ label }}</text>
+     </view>
  </view>
</view>

```



`➡️ components/custom-checkbox/custom-checkbox.wxss`

```css
/* components/custom-checkbox/custom-checkbox.wxss */

.custom-checkbox-container {
  display: inline-block;
}

.custom-checkbox-box {
  display: flex;
  align-items: center;
}

.custom-checkbox-box.left {
  flex-direction: row-reverse;
}

.custom-checkbox-box.right {
  flex-direction: row;
}

.custom-checkbox {
  margin-left: 10rpx;
}

```



`➡️ components/custom-checkbox/custom-checkbox.js`

```js
Component({

+   /**
+    * 组件的属性列表：组件的对外属性，主要用来接收组件使用者传递给组件内部的属性以及数据
+    */
+   properties: {
+     // 如果需要接收传递的属性，有两种方式：全写、简写
+     // label: String
+ 
+     label: {
+       // type 组件使用者传递的数据类型
+       // 数据类型：String、Number、Boolean、Object、Array
+       // 也可以设置为 null，表示不限制类型
+       type: String,
+       value: ''
+     },
+ 
+     // 文字显示位置
+     position: {
+       type: String,
+       value: 'right'
+     }
+   },

  /**
   * 组件的初始数据：用来定义当前组件内部所需要使用的数据
   */
  data: {
    isChecked: false
  },

  /**
   * 组件的方法列表：在组件中，所有的事件处理程序都需要写到 methods 方法中
   */
  methods: {
    
    // 更新复选框的状态
    updateChecked () {

      this.setData({
        isChecked: !this.data.isChecked,
+        // label: '在组件内部也可以修改 properties 中的数据'
      })

+       // 在 JS 中可以访问和获取 properties 中的数据
+       // 但是一般情况下，不建议修改，因为会造成数据流的混乱
+       // console.log(this.properties.label)
      // console.log(this.data.isChecked)
    }

  }
  
})
```







### 4. 组件 wxml 的 slot

![[Pasted image 20240425143833.png]]


在使用基础组件时，可以给组件传递子节点传递内容，从而将内容展示到页面中，自定义组件也可以接收子节点内容
只不过在组件模板中需要定义 `<slot />` 节点，用于承载组件引用时提供的子节点



<img src="http://8.131.91.46:6677/mina/base/自定义组件 slot.png" style="zoom:80%; border: 1px solid #ccc" />



默认情况下，一个组件的 wxml 中只能有一个 slot （默认插槽）。需要使用多 slot 时，可以在组件 js 中声明启用。

同时需要给 slot 添加 name 来区分不同的 slot，给子节点内容添加 slot 属性来将节点插入到 对应的 slot 中



<img src="http://8.131.91.46:6677/mina/base/组件-具名插槽.png" style="zoom:80%; border: 1px solid #ccc" />



**知识点讲解：**



`➡️ custom01.html`

```html
<view>
  <slot name="slot-top" />
  <!-- slot 就是用来接收、承载子节点内容 -->
  <!-- slot 只是一个占位符，子节点内容会将 slot 进行替换 -->
  <!-- 默认插槽 -->
  <view><slot /></view>

  <slot name="slot-bottom" />
</view>
```



`➡️ custom01.js`

```js
// components/custom01/custom01.js

Component({

  options: {
    // 启用多 slot 支持
    multipleSlots: true
  }

})
```



`➡️ cart.wxml`

```html
<custom01>
  <text slot="slot-top">我需要显示到顶部</text>
    
  <!-- 默认情况下，自定义组件的子节点内容不会进行展示 -->
  <!-- 如果想内容进行展示，需要再组件模板中定义 slot 节点 -->
  我是子节点内容
    
  <text slot="slot-bottom">我需要显示到低部</text>
</custom01>

```





**完善复选框案例**



`➡️ custom-checkbox.html`

```html
<!--components/custom-checkbox/custom-checkbox.wxml-->
<!-- <text>我是自定义组件</text> -->

<view class="custom-checkbox-container">
  <view class="custom-checkbox-box {{ position === 'right' ? 'right' : 'left' }}">
    <checkbox class="custom-checkbox" checked="{{ isChecked }}" bindtap="updateChecked" />

+     <view>
+       <!-- lable 和 子节点内容都进行了展示 -->
+       <!-- 要么展示 lable 要么展示 子节点内容 -->
+       <!-- 如果用户传递了 lable 属性，就展示 lable -->
+       <!-- 如果用户没有传递 lable 属性，就展示 子节点内容 -->
+       <text wx:if="{{ label !== '' }}">{{ label }}</text>
+ 
+       <slot wx:else />
+     </view>
  </view>
</view>

```



`➡️ index.html`

```html
<!-- label 文本显示的内容 -->
<!-- position 控制文本显示的位置 -->
<custom-checkbox label="我已阅读并同意 用户协议 和 隐私协议" position="right">
  我已阅读并同意 用户协议 和 隐私协议 - 111
</custom-checkbox>

<view class="line"></view>

<custom-checkbox label="匿名提交" position="left">
  匿名提交 - 222
</custom-checkbox>

```









### 5. 组件样式以及注意事项



**选择器使用注意事项：**



类似于页面，自定义组件拥有自己的 `wxss` 样式，组件对应 `wxss` 文件的样式，只对组件wxml内的节点生效。

编写组件样式时，需要注意以下几点：



1. app.wxss 或页面的 wxss 中使用了标签名（view）选择器（或一些其他特殊选择器）来直接指定样式
    这些选择器会影响到页面和全部组件，通常情况下这是不推荐的做法

2. 组件和引用组件的页面不能使用 id 选择器(#a)、属性选择器([a]) 和 标签名选择器，请改用 class 选择器

3. 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用

4. 子元素选择器（.a>.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。

5. 继承样式，如 font 、 color ，会从组件外继承到组件内。

6. 除继承样式外， 全局中的样式、组件所在页面的的样式对自定义组件无效 (除非更改组件样式隔离选项)



```css
#a { } /* 在组件中不能使用 */
[a] { } /* 在组件中不能使用 */
button { } /* 在组件中不能使用 */
.a > .b { } /* 除非 .a 是 view 组件节点，否则不一定会生效 */
```



**落地代码：**



`➡️ custom02.wxml`

```html
<text id="content" class="content son">
  <text class="label">给自定义组件设置样式</text>
</text>
```



`➡️ custom02.wxss`

```scss
/* components/custom02/custom02.wxss */

/* 第一个注意事项：在自定义的 wxss 文件中，不允许使用标签选择器，ID 选择器，属性选择器 */
/* 请改为 class 选择器 */
/* text {
  color: lightseagreen;
} */

/* #content {
  color: lightseagreen;
} */

/* [id=content] {
  color: lightseagreen;
} */

/* .content {
  color: lightseagreen;
} */

/* 第二个注意事项：子选择器，只能用于 view 和 子组件，用于其他组件可能会出现样式失效的问题 */
/* .content > .label {
  color: lightseagreen;
} */

/* 第三个注意事项：继承样式，例如：color\font 都会从组件外继承 */

/* 第四个注意事项：全局样式、组件所在页面的样式文件中的样式都对自定义组件无效 */

/* 第五个注意事项：官方不推荐做法 */
/* 不建议在 全局样式文件 以及 父级页面之间使用标签选择器设置样式 */
/* 如果是在全局样式文件中设置样式，会影响项目中全部的相同组件 */
/* 如果是再页面样式文件中设置样式，会影响当前页面所有的相同组件 */

/* 第六个注意事项： */
/* 组件和组件使用者，如果使用了后代选择器，可能会出现一些非预期情况 */
/* 如果出现，请避免 */

```



`➡️ cate.wxml`

```html
<view class="custom parent">
  <view>
    <custom02 />

    <view class="son test">我是父级页面中的结构</view>
  </view>
</view>
```



`➡️ cate.wxss`

```scss
/* pages/cate/cate.wxss */

/* .custom  {
  color: lightseagreen;
  font-size: 50rpx;
} */

/* .label {
  color: lightseagreen;
} */

/* text {
  color: lightseagreen;
} */

.parent .son.test {
  color: lightsalmon;
}
```



`➡️ app.wxss`

```scss
/* .label {
  color: lightseagreen;
} */

/* text {
  color: lightseagreen;
} */

```











### 6. 组件样式隔离



默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：



1. `app.wxss` 或页面的 `wxss` 中使用了标签名（view）选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。

2. 指定特殊的样式隔离选项 `styleIsolation` 

   ```js
   Component({
     options: {
       styleIsolation: 'isolated'
     }
   })
   ```

   

`styleIsolation` 选项它支持以下取值：

- `isolated` 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；
- `apply-shared` 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；
- `shared` 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 `apply-shared` 或 `shared` 的自定义组件。



**落地代码：**



`➡️ custom03.wxml`

```html
<!--components/custom03/custom03.wxml-->

<text class="label">演示组件样式隔离</text>
```



`➡️ custom03.wxss`

```scss
/* components/custom03/custom03.wxss */

.test {
  color: lightseagreen;
  font-size: 50rpx;
}
```



`➡️ custom03.js`

```js
// components/custom03/custom03.js
Component({

  options: {

    // styleIsolation：配置组件样式隔离

    // isolated：开启样式隔离，默认值
    // 在默认情况下，自定义组件和组件使用者如果存在相同的类名，类名不会相互影响

    // apply-shared：表示组件使用者、页面的 wxss 样式能够影响到自定义组件
    // 但是自定义组件的样式不会影响组件使用者、页面的 wxss 样式 
    // styleIsolation: "apply-shared"

    // shared：表示组件使用者、页面的 wxss 样式能够影响到自定义组件
    // 自定义组件的样式会影响组件使用者、页面的 wxss 样式
    // 和其他使用了 apply-share 以及 share 属性的自定义组件
    styleIsolation: 'shared'

  }
    
})
```





`➡️ cate.wxml`

```html
<custom03 />
```



`➡️ cate.wxss`

```scss
.label {
  color: lightsalmon;
}
```







### 7. 拓展-小程序修改checkbox样式



**知识点：**



技巧：在官方文档，找到官方提供的案例，审查元素，就能看到对应的类名



<img src="http://8.131.91.46:6677/mina/base/修改复选框样式.png" style="zoom:80%; border: 1px solid #ccc" />



> 📌 **注意事项**
>
> 
>
> 1. .custom-checkbox .wx-checkbox-input {}：复选框没有选中时默认的样式
> 2. .custom-checkbox .wx-checkbox-input-checked {}： 复选框选中时默认的样式
> 3. .custom-checkbox .wx-checkbox-input.wx-checkbox-input-checked:before {}：复选框选中时 √ 样式
>
> 
>
>
> 这几个类名，在全局样式文件、页面样式文件都可以对修改复选框样式，
>
> **`但是在自定义组件内部使用的时候，需要添加 styleIsolation: 'shared' 属性`**
>
> 





**落地代码：**



`➡️ components/custom-checkbox/custom-checkbox.wxss`

```scss
/* 复选框组件是公共组件 */
/* 以后需要再多个页面或者需要再多个项目中进行使用 */
/* 所以呢，需要先给复选框组件准备、设置一些默认样式 */
/* 如果在其他页面或者其他项目中使用的时候，发现样式不符合产品需求 */
/* 可以进行修改、对默认的样式进行修改 */

/* 1. 需要给复选框设置默认样式 */
/* 需要先找到小程序给复选框提供的类名，通过小程序给提供的类名修改才可以 */
/* 需要先打开小程序开发文档，找到复选框文档，审查元素，进行查找 */

/* 在自定义组件中，不能直接修改复选框样式 */
/* 如果需要进行修改，需要设置 styleIsolation 才可以 */
/* shared：修改其他页面的样式、组件使用者的样式、以及其他使用了 share 以及 apply-share 的组件 */
/* 这时候，不是想要的结果 */
/* 需求是：只想影响当前组件，可以添加命名空间 */

/* 复选框没有选中时默认的样式 */
.custom-checkbox .wx-checkbox-input {
  width: 24rpx !important;
  height: 24rpx !important;
  border-radius: 50% !important;
  border: 1px solid #fda007 !important;
  margin-top: -6rpx;
}

/* 复选框选中时默认的样式 */
.custom-checkbox .wx-checkbox-input-checked {
  background-color: #fda007 !important;
}

/* 复选框选中时 √ 样式 */
.custom-checkbox .wx-checkbox-input.wx-checkbox-input-checked:before {
  font-size: 22rpx;
  color: #fff;
}

/* 2. 组件使用者也能够修改默认的样式 */

```





`➡️ components/custom-checkbox/custom-checkbox.js`

```js
Component({

  options: {
    styleIsolation: 'shared'
  }
  
})
```





`➡️ index.wxss`

```scss
/* 组件使用者修改复选框的样式 */
.custom .custom-checkbox .wx-checkbox-input {
  border: 1px solid lightseagreen !important;
}

.custom .custom-checkbox .wx-checkbox-input-checked {
  background-color: lightseagreen !important;
}

```





### 8. 数据监听器



**知识点：**



数据监听器可以用于监听和响应任何属性和数据字段的变化，有时，需要在一些数据字段被 setData 设置时，需要执行一些操作。那么就可以使用 `observers` 数据监听器来实现。语法如下：



```js
Component({
  data: {
    num: 10,
    count: 1,
    obj: { name: 'Tom', age: 10 },
    arr: [1, 2, 3]
  },
  observers: {
    // key 是需要检测数据
    // value 是一个函数，函数接收一个形参作为参数，是最新的值
    num: function(newNum) {
      console.log(newNum)
    },
    
    // 数据监听器支持监听属性或内部数据的变化，可以同时监听多个
    'num, count': function (newNum, newCount) {
       console.log(newNum, newCount)
    }
    
    // 监听器可以监听子数据字段
    'obj.age': function(newAge) {
      console.log(newAge)
    },
    
    // 如果需要监听所有子数据字段的变化，可以使用通配符 ** 
    'obj.**': function(newAge) {
      console.log(newAge)
    },
        
    'arr[0]': function (val) {}
  }
})
```











### 9. 组件间通信与事件



#### 9.1 父往子传值



**知识点：**

父组件如果需要向子组件传递指定属性的数据，在 WXML 中需要使用数据绑定的方式

与普通的 WXML 模板类似，使用数据绑定，这样就可以向子组件的属性传递动态数据。



父组件如果需要向子组件传递数据，只需要两个步骤：

1.在父组件 WXML 中使用 数据绑定 的方式向子组件传递动态数据

2.子组件内部使用 properties 接收父组件传递的数据即可



**知识点代码：**



```html
<!-- 引用组件的页面模板 -->
<view>
  <costom prop-a="{{ name }}" prop-b="{{ age }}" />
</view>
```



在组件内部，需要在 `Component` 构造器中通过 `properties` 接收传递的数据，接收方式有两种：

```js
Component({
  /**
   * 组件的属性列表 props
   */
  properties: {
    propA: {
      type: String, // 传递的数据类型
      value: '' // 默认值
    },
    propB: Number // 简化的定义方式
  },

  // coding...
})

```



在子组件中也可以通过 `this.setData()` 对 `properties` 中的数据进行修改，但是一般不建议修改

```js
// components/custom01/custom01.js
Component({

  /**
   * 组件的方法列表
   */
  methods: {
    // 修改列表中的数据
    updateProp () {
      this.setData({
        propB: this.properties.propB + 1
      })
    }
  }
})

```





**复选框组件案例：**



`➡️ index.js`

```js
Page({

  data: {
    isChecked: true
  },
    
  // coding...

})
```



`➡️ index.wxml`

```html
<custom-checkbox
  label="我已阅读并同意 用户协议 和 隐私协议"
  position="right"
+   checked="{{ isChecked }}">
  我已阅读并同意 用户协议 和 隐私协议 - 111
</custom-checkbox>
```





`➡️ components/custom-checkbox/custom-checkbox.js`

```js
Component({

  options: {
    styleIsolation: 'shared'
  },

  properties: {
    
    // coding...

    // 复选框组件公共组件
    // 需要再多个页面、在多个项目中进行使用
    // 在使用的时候，有的地方希望默认是选中的效果，有的地方希望默认是没有被选中的效果
    // 怎么处理 ？
    // 首先让复选框默认还是没有被选中的效果
    // 如果希望复选框默认被选中，这时候传递属性(checked=true)到复选框组件
+     checked: {
+       type: Boolean,
+       value: false
+     }
  },

  /**
   * 组件的初始数据：用来定义当前组件内部所需要使用的数据
   */
  data: {
    isChecked: false
  },

+   observers: {
+     // 如果需要将 properties 中的数据赋值给 data
+     // 可以使用 observers 进行处理
+     checked: function (newChecked) {
+       // console.log(newChecked)
+       this.setData({
+         isChecked: newChecked
+       })
+     }
+   },

  /**
   * 组件的方法列表：在组件中，所有的事件处理程序都需要写到 methods 方法中
   */
  methods: {
    
    // 更新复选框的状态
    updateChecked () {

      this.setData({
+         isChecked: !this.data.isChecked,
+         // checked: !this.properties.checked
        // label: '在组件内部也可以修改 properties 中的数据'
      })

      // 在 JS 中可以访问和获取 properties 中的数据
      // 但是一般情况下，不建议修改，因为会造成数据流的混乱
      // console.log(this.properties.label)
      // console.log(this.data.isChecked)
    }

  }
  
})
```



`➡️ components/custom-checkbox/custom-checkbox.wxml`

```html
<!--components/custom-checkbox/custom-checkbox.wxml-->
<!-- <text>我是自定义组件</text> -->

<view class="custom-checkbox-container">
  <view class="custom-checkbox-box {{ position === 'right' ? 'right' : 'left' }}">
+     <checkbox class="custom-checkbox" checked="{{ isChecked }}" bindtap="updateChecked" />

    <view class="content">
      <!-- lable 和 子节点内容都进行了展示 -->
      <!-- 要么展示 lable 要么展示 子节点内容 -->
      <!-- 如果用户传递了 lable 属性，就展示 lable -->
      <!-- 如果用户没有传递 lable 属性，就展示 子节点内容 -->
      <text wx:if="{{ label !== '' }}">{{ label }}</text>

      <slot wx:else />
    </view>
  </view>
</view>

```







#### 9.2 子往父传值

![[Pasted image 20240425195344.png]]


子组件如果需要向父组件传递数据，可以通过小程序提供的事件系统实现传递传递，可以传递任意数据。

事件系统是组件间通信的主要方式之一，自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件，流程如下：



1. 自定义组件触发事件时，需要使用 `triggerEvent` 方法发射一个自定义的事件
2. 自定义组件标签上通过 bind 方法监听发射的事件



**触发事件：**

```html
<!-- 在自定义组件中 -->
<button type="primary" plain bindtap="sendData">传递数据</button>
```

```js
// components/custom05/custom05.js
Component({

  // 组件的初始数据
  data: {
    num: 666
  },

  // 组件的方法列表
  methods: {

    // 将数据传递给父组件
    sendData () {

      // 如果需要将数据传递给父组件
      // 需要使用 triggerEvent 发射自定义事件
      // 第二个参数，是携带的参数
      this.triggerEvent('myevent', this.data.num)
      
    }

  }
})
```



**监听事件：**

```html
<view>{{ num }}</view>
<!-- 需要在自定义组件标签上通过 bind 方法绑定自定义事件，同时绑定事件处理函数 -->
<custom05 bind:myevent="getData" />
```

```js
Page({

  data: {
    num: ''
  },

  getData (event) {
    // 可以通过事件对象.detail 获取子组件传递给父组件的数据
    // console.log(event)
    this.setData({
      num: event.detail
    })
  }

})

```





**复选框组件案例：**



`➡️ components/custom-checkbox/custom-checkbox.js`

```js
Component({

  /**
   * 组件的方法列表：在组件中，所有的事件处理程序都需要写到 methods 方法中
   */
  methods: {
    
    // 更新复选框的状态
    updateChecked () {

      this.setData({
        isChecked: !this.data.isChecked,
        // label: '在组件内部也可以修改 properties 中的数据'
      })

      // 在 JS 中可以访问和获取 properties 中的数据
      // 但是一般情况下，不建议修改，因为会造成数据流的混乱
      // console.log(this.properties.label)
      // console.log(this.data.isChecked)

+       // 目前复选框组件的状态是存储在复选框组件内部的、存储在自定义组件内部的
+       // 但是，在以后实际开发中，组件使用者、父组件有时候也需要获取到复选框内部的状态
+       // 怎么办 ？
+       // 这时候，自定义组件内部就需要发射一个自定义事件，
+       // 如果组件使用者、父组件需要使用数据，绑定自定义事件进行获取即可
+       this.triggerEvent('changechecked', this.data.isChecked)
    }

  }
  
})
```



`➡️ index.html`

```html
<custom-checkbox
  label="我已阅读并同意 用户协议 和 隐私协议"
  position="right"
  checked="{{ isChecked }}"
  class="getchild"
+  bind:changechecked="getData"
>
  我已阅读并同意 用户协议 和 隐私协议 - 111
</custom-checkbox>
```



`➡️ index.js`

```js
Page({

  data: {
    isChecked: true
  },

  getData (event) {
    console.log(event.detail)

    if (event.detail) {
      console.log('提交')
    } else {
      console.log('请同意协议！')
    }
  }

})
```







#### 9.3 获取组件实例



如果前面两种方式不足以满足需要。

可在父组件里调用 `this.selectComponent()` ，获取子组件的实例对象，就可以直接拿到子组件的任意数据和方法。调用时需要传入一个匹配选择器 `selector`，如：`this.selectComponent(".my-component")`。



```html
<!-- 父组件 -->
<costom bind:myevent="getData" class="custom" />
<button bindtap="getChildComponent"></button>
```



```js
// 父组件
Page({
  data: {},
  getChildComponent: function () {
    const child = this.selectComponent('.custom')
    console.log(child)
  }
})
```





**复选框组件案例：**



`➡️ index.html`

```html
<custom-checkbox
  label="我已阅读并同意 用户协议 和 隐私协议"
  position="right"
  checked="{{ isChecked }}"
+   class="child"
+  id="child"
  bind:changechecked="getData"
>
  我已阅读并同意 用户协议 和 隐私协议 - 111
</custom-checkbox>

<button type="primary" plain bindtap="getChild">获取子组件实例对象</button>

```



`➡️ index.js`

```js
Page({

  // coding...

  // 获取子组件的实例对象
  getChild () {

    // this.selectComponent 方法获取子组件实例对象
    // 获取到实例对象以后，就能获取子组件所有的数据、也能调用子组件的方法
    const res = this.selectComponent('#child')
    console.log(res.data.isChecked)

  }

})
```



















### 10. 组件生命周期

![[Pasted image 20240425211532.png]]


组件的生命周期：指的是组件自身的一些钩子函数，这些函数在特定的时间节点时被自动触发

组件的生命周期函数需要在 `lifetimes` 字段内进行声明

最重要的生命周期是 `created` `attached` `detached` 包含一个组件生命周期流程的最主要时间点



| 定义段     | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| `created`  | 在组件实例刚刚被创建时执行，注意此时不能调用 `setData ` （还没有对模板解析） |
| `attached` | 在组件实例进入页面节点树时执行 (模板已经解析完毕，并且挂载到页面上) |
| ready      | 在组件布局完成后执行                                         |
| moved      | 在组件实例被移动到节点树另一个位置时执行                     |
| `detached` | 在组件实例被从页面节点树移除时执行 (组件被销毁了)            |



<img src="http://8.131.91.46:6677/mina/base/组件生命周期.png" style="zoom:80%; border: 1px solid #ccc" />



1. 【组件实例刚刚被创建好时】， `created` 生命周期被触发。此时，组件数据 `this.data` 就是在 `Component` 构造器中定义的数据 `data` 。 **此时还不能调用 `setData` 。** 通常情况下，这个生命周期只应该用于给组件 `this` 添加一些自定义属性字段。

    

2. 【在组件完全初始化完毕】、进入页面节点树后， `attached` 生命周期被触发。此时， `this.data` 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。



3. 【在组件离开页面节点树后】， `detached` 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 `detached` 会被触发。



```js
Component({
  
  lifetimes: {
    created: function () {
      // 在组件实例刚刚被创建时执行，注意此时不能调用 setData 
      // 一般用来为组件添加一些自定义属性字段。
    },
    attached: function() {
      // attached 在组件完全初始化完毕、进入页面节点树后执行
      // 模板已经解析完毕，并且挂载到页面上
      // 一般都是在这里写对应的交互
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    },
    
    // coding...
  }
    
  // coding...
})
```









### 11. 组件所在页面的生命周期



组件还有一些特殊的生命周期，这类生命周期和组件没有很强的关联

主要用于组件内部监听父组件的展示、隐藏状态，从而方便组件内部执行一些业务逻辑的处理

组件所在页面的生命周期有 4 个： show、 hide、 resize、 routeDone，需要在 `pageLifetimes` 字段内进行声明



<img src="http://8.131.91.46:6677/mina/base/组件所在页面的生命周期.png" style="zoom:70%; border: 1px solid #ccc" />



```js
// components/custom06/custom06.js
Component({

  // coding...

  // 组件所在页面的生命周期
  pageLifetimes: {

    // 监听组件所在的页面展示(后台切前台)状态
    show () {
      console.log('组件所在的页面被展示')
    },

    // 监听组件所在的页面隐藏(前台切后台、点击 tabBar)状态
    hide () {
      console.log('组件所在的页面被隐藏')
    }

  }

})

```







### 12. 小程序生命周期总结



小程序冷启动，钩子函数执行的顺序



<img src="http://8.131.91.46:6677/mina/base/小程序生命周期总结-1.png" style="zoom:80%;border: 1px solid #ccc" />



保留当前页面(navigate) 以及 关闭当前页面(redirect)



<img src="http://8.131.91.46:6677/mina/base/小程序生命周期总结-2.png"  style="zoom:80%;border: 1px solid #ccc" />



切后台 以及 切前台(热启动)

<img src="http://8.131.91.46:6677/mina/base/小程序生命周期总结-3.png"  style="zoom:80%;border: 1px solid #ccc"  />







### 13. 拓展：使用 Component 构造页面

![[Pasted image 20240426151844.png]]

Component 方法用于创建自定义组件

小程序的页面也可以视为自定义组件，因此页面也可以使用 Component 方法进行创建，从而实现复杂的页面逻辑开发



> 📌 **注意事项：**
>
> 1. 要求对应 json 文件中包含 usingComponents 定义段
>
> 2. 页面使用 Component 构造器创建，需要定义与普通组件一样的字段与实例方法
>
> 3. 页面 Page 中的一些生命周期方法（如 onLoad() 等以“on”开头的方法），在 Component 中要写在 methods 属性中才能生效
>
> 4. 组件的属性 Properties 可以用于接收页面的参数，在 onLoad() 中可以通过 this.data 拿到对应的页面参数





**落地代码：**



```js
Component({

  // 为什么需要使用 Component 方法进行构造页面
  // Component 方法功能比 Page 方法强大很多
  // 如果使用 Component 方法构造页面，可以实现更加复杂的页面逻辑开发

  // 小程序页面也可以使用 Component 方法进行构造
  // 注意事项：
  // 1. 要求 .json 文件中必须包含 usingComponents 字段
  // 2. 里面的配置项需要和 Component 中的配置项保持一致
  // 3. 页面中 Page 方法有一些钩子函数、事件监听方法，这些钩子函数、事件监听方法必须方法 methods 对象中
  // 4. 组件的属性 properties 也可以接受页面的参数，在 onLoad 钩子函数中可以通过 this.data 进行获取

  properties: {
    id: String,
    title: String
  },

  data: {
    name: 'tom'
  },

  // onLoad () {
  //   console.log('页面加载 - 1')
  // },

  methods: {

    // 更新 name
    updateName() {
      this.setData({
        name: 'jerry'
      })
    },

    onLoad (options) {
      // console.log('页面加载 - 2')
      // console.log(options)
      console.log(this.data.id)
      console.log(this.data.title)
      console.log(this.properties.id)
    },

  }

})
```







### 14. 拓展：behaviors



小程序的 behaviors 方法是一种代码复用的方式，可以将一些通用的逻辑和方法提取出来，然后在多个组件中复用，从而减少代码冗余，提高代码的可维护性。



**如果需要 behavior 复用代码，需要使用 Behavior() 方法**，每个 behavior 可以包含一组属性、数据、生命周期函数和方法

组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。





**注册 behavior：**



如果需要注册一个 `behavior`，需要借助 `Behavior()` 方法，接受一个 `Object` 类型的参数



```js
// my-behavior.js

module.exports = Behavior({
  behaviors: [],
  properties: {
    myBehaviorProperty: {
      type: String
    }
  },
  data: {
    myBehaviorData: 'my-behavior-data'
  },
  created: function () {
    console.log('[my-behavior] created')
  },
  attached: function () {
    console.log('[my-behavior] attached')
  },
  ready: function () {
    console.log('[my-behavior] ready')
  },

  methods: {
    myBehaviorMethod: function () {
      console.log('[my-behavior] log by myBehaviorMehtod')
    },
  }
})
```



**使用 behavior：**

```js
// my-component.js
const myBehavior = require('my-behavior')

Component({
  behaviors: [myBehavior]
  
  // coding...
})
```





**组件和它引用的 behavior 中可以包含同名的字段，对这些字段的处理方法如下：**



1. 如果有同名的属性或方法，采用 “就近原则”，组件会覆盖 behavior 中的同名属性或方法

2. 如果有同名的数据字段且都是对象类型，会进行对象合并，其余情况会 采用 “就近原则” 进行数据覆盖

3. 生命周期函数和 observers 不会相互覆盖，会是在对应触发时机被逐个调用，也就是都会被执行



详细的规则：[同名字段的覆盖和组合规则](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html#同名字段的覆盖和组合规则)









### 15. 拓展：外部样式类



默认情况下，组件和组件使用者之间如果存在相同的类名不会相互影响，组件使用者如果想修改组件的样式，需要就解除样式隔离，但是解除样式隔离以后，在极端情况下，会产生样式冲突、CSS 嵌套太深等问题，从而给我们的开发带来一定的麻烦。



**外部样式类：在使用组件时，组件使用者可以给组件传入 CSS 类名，通过传入的类名修改组件的样式。**



如果需要使用外部样式类修改组件的样式，**在 Component 中需要用 externalClasses 定义若干个外部样式类。**



外部样式类的使用步骤：

1.在 Component 中用 externalClasses 定义段定义若干个外部样式类

2.自定义组件标签通过 属性绑定 的方式提供一个样式类，属性是 externalClasses 定义的元素，属性值是传递的类名

3.将接受到的样式类用于自定义组件内部



> 📌**注意事项：**
>
> ​	在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的
>
> ​	因此需要添加 !important 以保证外部样式类的优先级



**落地代码：**



`➡️ custom09.js`

```js
// components/custom09/custom09.js
Component({

  // 组件接受的外部样式类
  externalClasses: ['extend-class']
})
```



`➡️ custom09.wxml`

```html
<!-- 在同一个节点上，如果存在外部样式类 和 普通的样式类 -->
<!-- 两个类的优先级是未定义的 -->
<!-- 建议：在使用外部样式类的时，样式需要通过 !important 添加权重 -->
<view class="extend-class box">通过外部样式类修改组件的样式</view>

```



`➡️ custom09.wxss`

```scss
.box {
  color: lightseagreen;
}
```



`➡️ profile.wxml`

```html
<!-- 属性是在 externalClasses 里面定义的元素 -->
<!-- 属性值必须是一个类名 -->
<custom09 extend-class="my-class" />
```



`➡️ profile.wxss`

```scss
/* pages/index/index.wxss */

.my-class {
  color: lightsalmon !important;
}
```







### 16. 完善复选框案例并总结自定义组件



**总结自定义组件：**



1. 组件基本使用：数据、属性、方法、插槽

2. 组件样式使用：组件样式、注意事项、样式隔离、外部样式类

3. 组件通信传值：父往子传值、子往父传值、获取组件实例

4. 组件生命周期：组件的生命周期、组件所在页面的生命周期、总结了小程序全部的生命周期

5. 组件数据监听器：observers

6. 组件拓展：使用 Component 构造页面、组件复用机制 behaviors 等





**完善复选框案例**



`➡️ components/custom-checkbox/custom-checkbox.wxml`

```html
<!--components/custom-checkbox/custom-checkbox.wxml-->
<!-- <text>我是自定义组件</text> -->

<view class="custom-checkbox-container">
  <view class="custom-checkbox-box {{ position === 'right' ? 'right' : 'left' }}">
+    <label class="custom-label">
      <checkbox class="custom-checkbox" checked="{{ isChecked }}" bindtap="updateChecked" />

      <view class="content">
        <!-- lable 和 子节点内容都进行了展示 -->
        <!-- 要么展示 lable 要么展示 子节点内容 -->
        <!-- 如果用户传递了 lable 属性，就展示 lable -->
        <!-- 如果用户没有传递 lable 属性，就展示 子节点内容 -->
        <text wx:if="{{ label !== '' }}">{{ label }}</text>

        <slot wx:else />
      </view>
+    </label>
  </view>
</view>

```



`➡️ components/custom-checkbox/custom-checkbox.wxss`

```scss
+ .custom-checkbox-box .custom-label {
  display: flex;
  align-items: center;
}

```






































  

### 网络数据请求

![[attachments/Untitled 36 3.png|Untitled 36 3.png]]

  

![[attachments/Untitled 37 3.png|Untitled 37 3.png]]

GET请求

![[attachments/Untitled 38 3.png|Untitled 38 3.png]]

  

PUST请求

![[attachments/Untitled 39 3.png|Untitled 39 3.png]]

  

跳过request合法域名校验

![[attachments/Untitled 40 3.png|Untitled 40 3.png]]

  

  

  

![[attachments/Untitled 41 3.png|Untitled 41 3.png]]

  

  

### 总结

![[attachments/Untitled 42 3.png|Untitled 42 3.png]]

  

## 导航

#### 微信文档描述

![[attachments/Untitled 43 3.png|Untitled 43 3.png]]
##### **wx.switchTab(Object object)**

> 以 Promise 风格 调用：支持
> 
> **需要页面权限**：当前是插件页面时，宿主小程序不能调用该接口，反之亦然
> 
> **小程序插件**：支持，需要小程序基础库版本不低于 [2.3.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)
> 
> 在小程序插件中使用时，只能在当前插件的页面中调用
> 
> **微信 Windows 版**：支持
> 
> **微信 Mac 版**：支持

###### **功能描述**

跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面

##### **wx.reLaunch(Object object)**

> 基础库 1.1.0 开始支持，低版本需做兼容处理。

> 以 Promise 风格 调用：支持
> 
> **需要页面权限**：当前是插件页面时，宿主小程序不能调用该接口，反之亦然
> 
> **小程序插件**：支持，需要小程序基础库版本不低于 [2.3.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)
> 
> 在小程序插件中使用时，只能在当前插件的页面中调用
> 
> **微信 Windows 版**：支持
> 
> **微信 Mac 版**：支持

###### **功能描述**

关闭所有页面，打开到应用内的某个页面

  

  

##### **wx.redirectTo(Object object)**

> 以 Promise 风格 调用：支持
> 
> **需要页面权限**：当前是插件页面时，宿主小程序不能调用该接口，反之亦然
> 
> **小程序插件**：支持，需要小程序基础库版本不低于 [2.2.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)
> 
> 在小程序插件中使用时，只能在当前插件的页面中调用
> 
> **微信 Windows 版**：支持
> 
> **微信 Mac 版**：支持

###### **功能描述**

关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。

  

  

##### **wx.navigateTo(Object object)**

> 以 Promise 风格 调用：支持
> 
> **需要页面权限**：当前是插件页面时，宿主小程序不能调用该接口，反之亦然
> 
> **小程序插件**：支持，需要小程序基础库版本不低于 [2.2.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)
> 
> 在小程序插件中使用时，只能在当前插件的页面中调用
> 
> **微信 Windows 版**：支持
> 
> **微信 Mac 版**：支持

###### **功能描述**

保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 [wx.navigateBack](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html) 可以返回到原页面。小程序中页面栈最多十层。

  

##### **wx.navigateBack(Object object)**

> 以 Promise 风格 调用：支持
> 
> **需要页面权限**：当前是插件页面时，宿主小程序不能调用该接口，反之亦然
> 
> **小程序插件**：支持，需要小程序基础库版本不低于 [2.1.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)
> 
> 在小程序插件中使用时，只能在当前插件的页面中调用
> 
> **微信 Windows 版**：支持
> 
> **微信 Mac 版**：支持

###### **功能描述**

关闭当前页面，返回上一页面或多级页面。可通过 [getCurrentPages](https://developers.weixin.qq.com/miniprogram/dev/reference/api/getCurrentPages.html) 获取当前的页面栈，决定需要返回几层。

  


#### 声明式导航

![[attachments/Untitled 44 3.png|Untitled 44 3.png]]

  

  

![[attachments/Untitled 45 3.png|Untitled 45 3.png]]

  

![[attachments/Untitled 46 3.png|Untitled 46 3.png]]

  

  

#### 编程式导航

![[attachments/Untitled 47 3.png|Untitled 47 3.png]]

![[attachments/Untitled 48 3.png|Untitled 48 3.png]]

  

![[attachments/Untitled 49 3.png|Untitled 49 3.png]]

  

![[attachments/Untitled 50 3.png|Untitled 50 3.png]]

![[attachments/Untitled 51 3.png|Untitled 51 3.png]]

  

#### 导航传参

![[attachments/Untitled 52 3.png|Untitled 52 3.png]]

![[attachments/Untitled 53 3.png|Untitled 53 3.png]]

  

### 上下拉刷新

  

![[attachments/Untitled 54 3.png|Untitled 54 3.png]]

  

![[attachments/Untitled 55 3.png|Untitled 55 3.png]]

  

![[attachments/Untitled 56 3.png|Untitled 56 3.png]]

  

![[attachments/Untitled 57 3.png|Untitled 57 3.png]]

  

![[attachments/Untitled 58 2.png|Untitled 58 2.png]]


### WXS

  

![[attachments/Untitled 64 2.png|Untitled 64 2.png]]

![[attachments/Untitled 65 2.png|Untitled 65 2.png]]

  

![[attachments/Untitled 66 2.png|Untitled 66 2.png]]

  

### WXS基础语法

![[attachments/Untitled 67 2.png|Untitled 67 2.png]]

![[attachments/Untitled 68 2.png|Untitled 68 2.png]]

  

### 特点

![[attachments/Untitled 69 2.png|Untitled 69 2.png]]

  

![[attachments/Untitled 70 2.png|Untitled 70 2.png]]

  

![[attachments/Untitled 71 2.png|Untitled 71 2.png]]

  

![[attachments/Untitled 72 2.png|Untitled 72 2.png]]

![[attachments/Untitled 73 2.png|Untitled 73 2.png]]