## 从浏览器地址栏输入 url 到显示页面的步骤

### **基础版本**：

1. 浏览器根据请求的 `URL` 交给 `DNS` **域名解析**，找到真实 `IP` ，向服务器**发起请求**；
    
2. 服务器交给后台处理完成后**返回数据**，浏览器**接收⽂件**（ `HTML`、`JS`、`CSS` 、图象等）；
    
3. 浏览器对加载到的资源（ `HTML`、`JS`、`CSS` 等）进⾏语法解析，建立相应的内部数据结构 （如 `HTML` 的 `DOM`）；
    
4. **载⼊解析**到的资源⽂件，**渲染页面**，完成。
    

### **详细版**：

1、在浏览器地址栏输⼊`URL`

2、浏览器**查看缓存**，如果请求资源在缓存中并且新鲜，跳转到转码步骤

- 如果资源未缓存，发起新请求
    
- 如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验证。
    
- 检验新鲜通常有两个`HTTP`头进⾏控制 `Expires` 和 `Cache-Control`：
    
    - HTTP1.0提供 `Expires`，值为⼀个绝对时间表示缓存新鲜⽇期
    - HTTP1.1增加了`Cache-Control: max-age=time`，值为以秒为单位的最⼤新鲜时间

3、浏览器**解析URL**获取协议，主机，端⼝，`path`

4、浏览器**组装⼀个HTTP（GET）请求报⽂**

5、浏览器**获取主机 `ip` 地址**，过程如下：

- 浏览器缓存
    
- 本机缓存
    
- `hosts`⽂件
    
- 路由器缓存
    
- `ISP` `DNS`缓存
    
- `DNS`递归查询（可能存在负载均衡导致每次`IP`不⼀样）
    

6、**打开⼀个`socket`与⽬标`IP`地址，端⼝建⽴`TCP`链接**，三次握⼿如下：

- 客户端发送⼀个`TCP`的**SYN=1**，**Seq=X**的包到服务器端口
    
- 服务器发回**SYN=1**， **ACK=X+1**， **Seq=Y**的响应包
    
- 客户端发送**ACK=Y+1**， **Seq=Z**
    

7、`TCP`链接建⽴后**发送`HTTP`请求**

8、服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使⽤`HTTP` `Host`头部判断请求的服务程序

9、服务器检查**`HTTP`请求头是否包含缓存验证信息**，如果验证缓存新鲜，返回304等对应状态码

10、处理程序读取完整请求并准备`HTTP`响应，可能需要查询数据库等操作

11、服务器将**响应报⽂通过`TCP`连接发送回浏览器**

12、浏览器接收`HTTP`响应，然后根据情况**选择关闭`TCP`连接或者保留重⽤**，关闭`TCP`连接的四次握⼿如下：

- 主动⽅发送**Fin=1**， **Ack=Z**， **Seq= X**报⽂
    
- 被动⽅发送**ACK=X+1**， **Seq=Z**报⽂
    
- 被动⽅发送**Fin=1**， **ACK=X**， **Seq=Y**报⽂
    
- 主动⽅发送**ACK=Y**， **Seq=X**报⽂
    

13、浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同

14、如果资源可缓存，**进行缓存**

15、对响应**进行解码**（例如gzip压缩）

16、根据资源类型决定如何处理（假设资源为HTML⽂档）

17、**解析HTML⽂档**，**构件DOM树**，**下载资源**，**构造CSSOM树**，**执⾏js脚本**，这些操作没有严 格的先后顺序，以下分别解释：

16、**构建DOM树**：

- **Tokenizing**：根据`HTML`规范将字符流解析为标记
    
- **Lexing**：词法分析将标记转换为对象并定义属性和规则
    
- **DOM construction**：根据HTML标记关系将对象组成`DOM`树
    

17、解析过程中遇到图⽚、样式表、js⽂件，启动**下载**

18、**构建CSSOM树**：

- **Tokenizing**：字符流转换为标记流
    
- **Node**：根据标记创建节点
    
- **CSSOM**：节点创建`CSSOM`树
    

19、**根据DOM树和CSSOM树构建渲染树** :

- 从`DOM`树的根节点遍历所有可⻅节点，不可⻅节点包括：
    
    - `script` , `meta` 这样本身 不可⻅的标签。
    - 被`css`隐藏的节点，如 `display: none`
- 对每⼀个可⻅节点，找到恰当的`CSSOM`规则并应⽤
    
- 发布可视节点的内容和计算样式
    

20、`js`解析如下：

- 浏览器创建`Document`对象并解析`HTML`，将解析到的元素和⽂本节点添加到⽂档中，此时**`document.readystate`为`loading`**
    
- `HTML`解析器遇到**没有`async`和`defer`的`script`时**，将他们添加到⽂档中，然后执⾏⾏内 或外部脚本。这些脚本会同步执⾏，并且在脚本下载和执⾏时解析器会暂停。这样就可以⽤`document.write()`把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作`script`和他们之前的⽂档内容
    
- 当解析器遇到**设置了`async`属性的`script`时**，开始下载脚本并继续解析⽂档。脚本会在它 下载完成后尽快执⾏，但是解析器不会停下来等它下载。异步脚本禁止使⽤ **document.write()**，它们可以访问⾃⼰`script`和之前的⽂档元素
    
- 当⽂档完成解析，`document.readState`变成`interactive`
    
- 所有defer脚本会按照在⽂档出现的顺序执⾏，延迟脚本能访问完整⽂档树，禁止使⽤ `document.write()`
    
- 浏览器在`Document`对象上触发`DOMContentLoaded`事件
    
- 此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊ 并且所有异步脚本完成载⼊和执⾏，`document.readState`变为`complete`，`window`触发 `load`事件
    

21、显示⻚⾯（HTML解析过程中会逐步显示⻚⾯）

### 详细简版：

1. 从浏览器接收 `url` 到开启⽹络请求线程（这⼀部分可以展开浏览器的机制以及进程与线程 之间的关系）
2. 开启⽹络线程到发出⼀个完整的 `HTTP` 请求（这⼀部分涉及到dns查询， TCP/IP 请求，五层因特⽹协议栈等知识）
3. 从服务器接收到请求到对应后台接收到请求（这⼀部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
4. 后台和前台的 `HTTP` 交互（这⼀部分包括 HTTP 头部、响应码、报⽂结构、 cookie 等知 识，可以提下静态资源的 cookie 优化，以及编码解码，如 gzip 压缩等）
5. 单独拎出来的缓存问题， HTTP 的缓存（这部分包括http缓存头部， ETag ， catchcontrol 等）
6. 浏览器接收到 `HTTP` 数据包后的解析流程（解析 `html`、 词法分析然后解析成 `dom` 树、解析 `css` ⽣成 `css` 规则树、合并成 `render` 树，然后 `layout` 、 `painting` 渲染、复合图层的合成、 `GPU` 绘制、外链资源的处理、 `loaded` 和 `DOMContentLoaded` 等）
7. `CSS` 的可视化格式模型（元素的渲染规则，如包含块，控制框， `BFC` ， `IFC` 等概念）
8. `JS` 引擎解析过程（ `JS` 的解释阶段，预处理阶段，执⾏阶段⽣成执⾏上下⽂， `VO` ，作 ⽤域链、回收机制等等）
9. 其它（可以拓展不同的知识模块，如跨域，`web`安全， `hybrid` 模式等等内容）