## 什么是TCP协议？

TCP( Transmission control protocol )即传输控制协议，是一种**面向连接**、**可靠的**数据传输协议，它是为了在不可靠的互联网上提供可靠的端到端[字节流](https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E6%B5%81&spm=1001.2101.3001.7020)而专门设计的一个传输协议。

- **面向连接**：数据传输之前客户端和服务器端必须建立连接
- **可靠的**：数据传输是有序的 要对数据进行校验

### TCP[三次握手](https://so.csdn.net/so/search?q=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&spm=1001.2101.3001.7020)

为了保证客户端和服务器端的可靠连接，TCP建立连接时**必须**要进行三次会话，也叫TCP三次握手，**进行三次握手的目的是为了确认双方的接收能力和发送能力是否正常。**

举个栗子  
公安局长王哥 和 陈某打电话

公安局：你好！陈某，听得到吗？（一次会话）  
陈某：听到了，王哥，你能听到吗 （二次会话）  
公安局：听到了，你过来自首吧 （开始会话）（三次会话）

通过这个例子我们可以知道三次会话的目的就是为了确保双方的连接正常，同理，TCP三次握手也是这个过程，下面用图文形式来解释一下TCP三次握手。

**TCP建立连接过程**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/7bfb98fdba4740d2a5afaaef8cf9ab98.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzU2NjQ5NTU3,size_16,color_FFFFFF,t_70)

最开始的时候客户端和服务器都是处于CLOSED关闭状态。主动打开连接的为客户端，被动打开连接的是服务器。

TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 **LISTEN 监听状态**

**第一次握手** TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 **SYN-SENT 同步已发送状态**

**第二次握手** TCP服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了 **SYN-RCVD 同步收到状态**

**第三次握手** TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入**ESTABLISHED已建立连接状态** 触发三次握手

有人可能会很疑惑为什么要进行第三次握手？  
**主要原因：防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误**

- 第一次握手： 客户端向服务器端发送报文  
    证明客户端的发送能力正常
- 第二次握手：服务器端接收到报文并向客户端发送报文  
    证明服务器端的接收能力、发送能力正常
- 第三次握手：客户端向服务器发送报文  
    证明客户端的接收能力正常

**如果采用两次握手会出现以下情况：**  
客户端向服务器端发送的请求报文由于网络等原因滞留，未能发送到服务器端，此时连接请求报文失效，客户端会再次向服务器端发送请求报文，之后与服务器端建立连接，当连接释放后，由于网络通畅了，第一次客户端发送的请求报文又突然到达了服务器端，这条请求报文本该失效了，但此时服务器端误认为客户端又发送了一次连接请求，两次握手建立好连接，此时客户端忽略服务器端发来的确认，也不发送数据，造成不必要的错误和网络资源的浪费。

如果采用三次握手的话，就算那条失效的报文发送到服务器端，服务器端确认并向客户端发送报文，但此时客户端不会发出确认，由于客户端没有确认，由于服务器端没有接收到确认，就会知道客户端没有请求连接。

### TCP四次挥手

建立TCP连接需要三次握手，终止TCP连接需要四次挥手

举个例子  
张三和李四的对话

张三：好的，那我先走了  
李四：好的，那你走吧  
李四：那我也走了？  
张三：好的，你走吧

![在这里插入图片描述](https://img-blog.csdnimg.cn/3ca4f59c07ed4c83b9ca7a16ba8344f7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzU2NjQ5NTU3,size_16,color_FFFFFF,t_70)  
数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。

**第一次挥手** 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，**客户端进入FIN-WAIT-1（终止等待1）状态**

**第二次挥手** 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，**服务端就进入了CLOSE-WAIT 关闭等待状态**

**第三次挥手** 客户端接收到服务器端的确认请求后，**客户端就会进入FIN-WAIT-2（终止等待2）状态**，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，**服务器就进入了LAST-ACK（最后确认）状态**，等待客户端的确认。

**第四次挥手** 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，**客户端就进入了TIME-WAIT（时间等待）状态**，但此时TCP连接还未终止，必须要**经过2MSL**后（最长报文寿命），当客户端撤销相应的TCB后，**客户端才会进入CLOSED关闭状态**，服务器端接收到确认报文后，会**立即进入CLOSED关闭状态**，到这里TCP连接就断开了，四次挥手完成

**为什么客户端要等待2MSL？**  
主要原因是为了保证客户端发送那个的第一个ACK报文能到到服务器，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文。