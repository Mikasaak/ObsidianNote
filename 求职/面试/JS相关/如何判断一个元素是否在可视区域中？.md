# 面试官：如何判断一个元素是否在可视区域中？

![](https://static.vue-js.com/d848c790-8a05-11eb-85f6-6fac77c0c9b3.png)

## [#](https://vue3js.cn/interview/JavaScript/visible.html#%E4%B8%80%E3%80%81%E7%94%A8%E9%80%94)一、用途

可视区域即我们浏览网页的设备肉眼可见的区域，如下图

![](https://static.vue-js.com/9c5bbb10-8a56-11eb-85f6-6fac77c0c9b3.png)

在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：

- 图片的懒加载
- 列表的无限滚动
- 计算广告元素的曝光情况
- 可点击链接的预加载

## [#](https://vue3js.cn/interview/JavaScript/visible.html#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)二、实现方式

判断一个元素是否在可视区域，我们常用的有三种办法：

- offsetTop、scrollTop
    
- getBoundingClientRect
    
- Intersection Observer
    

### [#](https://vue3js.cn/interview/JavaScript/visible.html#offsettop%E3%80%81scrolltop)offsetTop、scrollTop

`offsetTop`，元素的上外边框至包含元素的上内边框之间的像素距离，其他`offset`属性如下图所示：

![](https://static.vue-js.com/b4b63ca0-8a54-11eb-85f6-6fac77c0c9b3.png)

下面再来了解下`clientWidth`、`clientHeight`：

- `clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`
- `clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`

这里可以看到`client`元素都不包括外边距

最后，关于`scroll`系列的属性如下：

- `scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小
    
- `scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置
    
- - 垂直滚动 `scrollTop > 0`
    - 水平滚动 `scrollLeft > 0`
- 将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置
    

#### [#](https://vue3js.cn/interview/JavaScript/visible.html#%E6%B3%A8%E6%84%8F)注意

- 上述属性都是只读的，每次访问都要重新开始

下面再看看如何实现判断：

公式如下：

```
el.offsetTop - document.documentElement.scrollTop <= viewPortHeight
```

1  

代码实现：

```js
function isInViewPortOfOne (el) {
    // viewPortHeight 兼容所有浏览器写法
    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
    const offsetTop = el.offsetTop
    const scrollTop = document.documentElement.scrollTop
    const top = offsetTop - scrollTop
    return top <= viewPortHeight
}
```


### [#](https://vue3js.cn/interview/JavaScript/visible.html#getboundingclientrect)getBoundingClientRect

返回值是一个 `DOMRect`对象，拥有`left`, `top`, `right`, `bottom`, `x`, `y`, `width`, 和 `height`属性

```js
const target = document.querySelector('.target');
const clientRect = target.getBoundingClientRect();
console.log(clientRect);

// {
//   bottom: 556.21875,
//   height: 393.59375,
//   left: 333,
//   right: 1017,
//   top: 162.625,
//   width: 684
// }
```



属性对应的关系图如下所示：

![](https://static.vue-js.com/e34ac5d0-8a05-11eb-85f6-6fac77c0c9b3.png)

当页面发生滚动的时候，`top`与`left`属性值都会随之改变

完全出现视窗之内：
- top 大于等于 0
- left 大于等于 0
- bottom 小于等于视窗高度
- right 小于等于视窗宽度

部分出现视窗之内：
- top 小于等于视窗高度
- left 小于等于视窗宽度
- bottom 大于等于0
- right 大于等于0

其他为未出现

实现代码如下：

```js
isVisibleEl(el) {  
  const rect = el.getBoundingClientRect();  
  const viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);//获取当前窗口的高度  
  const viewWidth = Math.max(document.documentElement.clientWidth, window.innerWidth);//获取当前窗口的宽度  
  let top = rect.top;//获取元素相对窗口的top值  
  let bottom = rect.bottom;//获取元素相对窗口的bottom值  
  let left = rect.left;//获取元素相对窗口的left值  
  let right = rect.right;//获取元素相对窗口的right值  
  console.log('viewHeight', viewHeight)  
  console.log('viewWidth', viewWidth)  
  console.log('top', top)  
  console.log('bottom', bottom)  
  console.log('left', left)  
  console.log('right', right)  
  // 判断元素完全出现在可视窗口  
  if (bottom <= viewHeight && top >= 0 && left >= 0 && right <= viewWidth) {  
    console.log('元素完全出现在可视窗口');  
  } else if (top <= viewHeight && bottom >= 0 && left <= viewWidth && right >= 0) {  
    console.log('元素部分出现在可视窗口');  
  } else {  
    console.log('元素未出现在可视窗口');  
  }  
  
},
```


### [#](https://vue3js.cn/interview/JavaScript/visible.html#intersection-observer)Intersection Observer

[[Code/JavaScript/交叉观察器 API-MDN.html | IntersectionObserver-MDN]]

`Intersection Observer` 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比`getBoundingClientRect`会好很多

使用步骤主要分为两步：创建观察者和传入被观察者

#### [#](https://vue3js.cn/interview/JavaScript/visible.html#%E5%88%9B%E5%BB%BA%E8%A7%82%E5%AF%9F%E8%80%85)创建观察者

```js
const options = {
  // 表示重叠面积占被观察者的比例，从 0 - 1 取值，
  // 1 表示完全被包含
  threshold: 1.0, 默认为0
  root:document.querySelector('#scrollArea') // (必须是目标元素的祖先元素)默认为null
};

const callback = (entries, observer) => { ....}

const observer = new IntersectionObserver(callback, options);
```
在VueUse库中useIntersectionObserver中的observe的root为null也就是默认的文档

传递到 [`IntersectionObserver()`](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/IntersectionObserver "IntersectionObserver()") 构造函数的 `options` 对象，可以控制在什么情况下调用观察器的回调。它有以下字段：

[`root`](app://obsidian.md/index.html#root)

用作视口的元素，用于检查目标的可见性。必须是目标的祖先。如果未指定或为 `null`，则默认为浏览器视口。

[`rootMargin`](app://obsidian.md/index.html#rootmargin)

根周围的边距。其值可以类似于 CSS [`margin`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin) 属性，例如 `"10px 20px 30px 40px"`（上、右、下、左）。这些值可以是百分比。在计算交叉点之前，这组值用于增大或缩小根元素边框的每一侧。默认值为全零。

[`threshold`](app://obsidian.md/index.html#threshold)

一个数字或一个数字数组，表示目标可见度达到多少百分比时，观察器的回调就应该执行。如果只想在能见度超过 50% 时检测，可以使用 0.5 的值。如果希望每次能见度超过 25% 时都执行回调，则需要指定数组 [0, 0.25, 0.5, 0.75, 1]。默认值为 0（这意味着只要有一个像素可见，回调就会运行）。值为 1.0 意味着在每个像素都可见之前，阈值不会被认为已通过。


通过`new IntersectionObserver`创建了观察者 `observer`，传入的参数 `callback` 在重叠比例超过 `threshold` 时会被执行`
关于`callback`回调函数常用属性如下：
```js
// 上段代码中被省略的 callback
const callback = function(entries, observer) { 
    entries.forEach(entry => {
        entry.time;               // 触发的时间
        entry.rootBounds;         // 根元素的位置矩形，这种情况下为视窗位置
        entry.boundingClientRect; // 被观察者的位置举行
        entry.intersectionRect;   // 重叠区域的位置矩形
        entry.intersectionRatio;  // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）
        entry.target;             // 被观察者
    });
};
```
每当目标满足该 `IntersectionObserver` 指定的阈值（threshold），回调被调用。回调接收 IntersectionObserverEntry 对象和观察器的列表：
IntersectionObserverEntry列表中的长度是根据observer.observe(target); 观测的元素决定的
#### [#](https://vue3js.cn/interview/JavaScript/visible.html#%E4%BC%A0%E5%85%A5%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85)传入被观察者

通过 `observer.observe(target)` 这一行代码即可简单的注册被观察者

```js
const target = document.querySelector('.target');
observer.observe(target);
```

我的代码
```js
myUseIntersectionObserver(target) {  
  // 创建一个新的 IntersectionObserver 实例  
  const observer = new IntersectionObserver(entries => {  
    // entries 是一个 IntersectionObserverEntry 对象的数组  
    // 检查每个目标元素的可见性  
    entries.forEach(entry => {  
      // 如果目标元素可见  
      if (entry.isIntersecting) {  
        console.log('entryTarget', entry.target)  
        // 在控制台打印日志  
        console.log('Element is visible');  
        // 进行你想要执行的操作，比如显示元素、加载内容等  
      } else {  
        // 如果目标元素不可见  
        // 在控制台打印日志  
        console.log('entryTarget', entry.target)  
        console.log('Element is not visible');  
        // 进行你想要执行的操作，比如隐藏元素、停止加载内容等  
      }  
    });  
  });  
  // 开始观察目标元素  
  observer.observe(target);  
},
```

### [#](https://vue3js.cn/interview/JavaScript/visible.html#%E4%B8%89%E3%80%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90)三、案例分析

实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色

`Html`结构如下：

```
<div class="container"></div>
```



`css`样式如下：

```css
.container {
    display: flex;
    flex-wrap: wrap;
}
.target {
    margin: 5px;
    width: 20px;
    height: 20px;
    background: red;
}
```



往`container`插入1000个元素

```js
const $container = $(".container");

// 插入 100000 个 <div class="target"></div>
function createTargets() {
  const htmlString = new Array(100000)
    .fill('<div class="target"></div>')
    .join("");
  $container.html(htmlString);
}
```



这里，首先使用`getBoundingClientRect`方法进行判断元素是否在可视区域

```js
function isInViewPort(element) {
    const viewWidth = window.innerWidth || document.documentElement.clientWidth;
    const viewHeight =
          window.innerHeight || document.documentElement.clientHeight;
    const { top, right, bottom, left } = element.getBoundingClientRect();

    return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;
}
```


然后开始监听`scroll`事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为`yellow`

```js
$(window).on("scroll", () => {
    console.log("scroll !");
    $targets.each((index, element) => {
        if (isInViewPort(element)) {
            $(element).css("background-color", "yellow");
        }
    });
});
```



通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了`scroll`事件，`scroll`事件伴随了大量的计算，会造成资源方面的浪费

下面通过`Intersection Observer`的形式同样实现相同的功能

首先创建一个观察者

```js
const observer = new IntersectionObserver(getYellow, { threshold: 1.0 });
```



`getYellow`回调函数实现对背景颜色改变，如下：

```js
function getYellow(entries, observer) {
    entries.forEach(entry => {
        $(entry.target).css("background-color", "yellow");
    });
}
```



最后传入观察者，即`.target`元素

```js
$targets.each((index, element) => {
    observer.observe(element);
});
```


可以看到功能同样完成，并且页面不会出现卡顿的情况

## [#](https://vue3js.cn/interview/JavaScript/visible.html#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE)参考文献

- https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
- https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API