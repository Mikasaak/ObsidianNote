---
date_created: 2024-04-6日 星期六 , 10:22:16 晚上
date_modified: 2024-04-6日 星期六 , 10:28:48 晚上
---
## 一、事件和事件流

### 1、什么是事件

**事件是可以被 JavaScript 侦测到的行为。** 鼠标点击、鼠标移动、鼠标滚动、按下键盘，浏览器窗口大小的改变，网页加载完成，关闭网页等等都会发生事件。
JavaScript和HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间。可以使用监听器（或事件处理程序）来预定事件，以便事件发生时执行相应的代码。通俗的说，这种模型其实就是一个观察者模式。（事件是对象主题，而这一个个的监听器就是一个个观察者）

### 2、什么是事件流

**事件流，描述的是页面中接受事件的顺序。**

![在这里插入图片描述](https://ask.qcloudimg.com/http-save/yehe-1987089/1bf55a9618ea4831f90412f31fbc8793.jpeg)

在这里插入图片描述
一个完整的JS事件流是从window开始，最后回到window的一个过程。
事件流被分为三个阶段(1~ 5)捕获过程、(5~ 6)事件触发过程、(6~ 10)冒泡过程。

DOM2级事件规定的事件流包括三个阶段： （1）事件捕获阶段 （2）处于目标阶段 （3）事件冒泡阶段


![](https://pic3.zhimg.com/v2-4fa0e50fe4db2b07d525c11cac81c172_r.jpg)

## 二、事件冒泡

看了上面的那张图应该对事件冒泡有了大概的了解了吧。总结来说就是： **当一个元素接收到事件的时候 会把他接收到的事件传给自己的父级，一直到window。**

如果它的父级元素也有某个事件函数，当执行完它的事件函数后，也就会执行它父级的事件函数。

- 用代码感受下一下什么是事件冒泡：

```javascript
<div class="parents" id="parents">
    <div class="child" id="child"></div>
</div>
```

复制

实例图：

![在这里插入图片描述](https://ask.qcloudimg.com/http-save/yehe-1987089/a1a8beec1d3f4b62cc2d98af9ebee6b0.png)

在这里插入图片描述

```javascript
<script>
    var parents = document.getElementById("parents");
    var child = document.getElementById("child");


    document.onclick = function(e){
        alert("你点击了屏幕任何区域");
    };

    document.body.onclick = function(e){
        alert("你点击了body区域");
    };

    parents.onclick = function (e) {
        alert("你点击了parents区域");
    };

    child.onclick = function (e) {
        alert("你点击了child区域");
    };

</script>
```


- 当**点击区域①**的时候：会依次弹出`你点击了child区域` 、`你点击了parents区域` 、 `你点击了body区域` 、 `你点击了屏幕任何区域` 这四个弹框。
- 当**点击区域②**的时候：会依次弹出`你点击了parents区域` 、 `你点击了body区域` 、 `你点击了屏幕任何区域` 这三个弹框。
- 当**点击区域③**的时候：会弹出 `你点击了body区域` 、 `你点击了屏幕任何区域` 这两个弹框。
- 当**点击区域④**的时候：就只弹出 `你点击了屏幕任何区域` 这一个弹框。

## 三、阻止冒泡

### 1、JS阻止事件冒泡

我们用 e.stopPropagation() 这个方法添加到某事件函数里的末尾，就可以做到阻止冒泡事件。但是IE8及以下不支持**e.stopPropagation()** 方法，所以就封装一个方法。

```javascript
<script>
    function stopPropagation(e) {
        e = e || window.event;
        if(e.stopPropagation) {
            e.stopPropagation(); //W3C阻止冒泡方法
        } else {
            e.cancelBubble = true; //IE阻止冒泡方法
        }
    }
</script>
```


在**child**（区域①）的点击事件函数最后添加 stopPropagation(e) 方法。

```javascript
<script>
    child.onclick = function (e) {
        alert("你点击了child区域");
        stopPropagation(e);
    };
</script>
```



- 再次点击区域①的时候就只弹出 `你点击了child区域` 这一个弹框。

### 2、JQ阻止事件冒泡

jq阻止事件冒泡就简单了，直接在事件函数里面添加 return false; 就行了。

```javascript
<script>
    $("#parents").click(function () {
       alert("你点击了parents区域")
    });
    $("#child").click(function () {
        alert("你点击了child区域");
        return false;
    });
</script>
```

复制

## 四、事件捕获

讲事件捕获之前先了解下**addEventListener()**方法：

**addEventListener()定义与用法**

- document.addEventListener() 方法用于向文档添加事件句柄。
- 提示： 可以使用 document.removeEventListener() 方法来移除 addEventListener() 方法添加的 事件句柄。
- 提示：使用 element.addEventListener() 方法为指定元素添加事件句柄。

**语法:**

```javascript
document.addEventListener(event, function, useCapture);
```



**参数值:**

| 参数         | 描述                                                                                                               |
| ---------- | ---------------------------------------------------------------------------------------------------------------- |
| event      | 必需。描述事件名称的字符串。 注意： 不要使用 “on” 前缀。例如，使用 “click” 来取代 “onclick”。 提示： 所有 HTML DOM 事件，可以查看我们完整的 HTML DOM Event 对象参考手册。 |
| function   | 必需。描述了事件触发后执行的函数。 当事件触发时，事件对象会作为第一个参数传入函数。事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。                  |
| useCapture | 可选。布尔值，指定事件是否在捕获或冒泡阶段执行。 可能值： true - 事件句柄在捕获阶段执行 false - 默认。事件句柄在冒泡阶段执行                                          |

从上面的表格中，可以看到参数值`useCapture`，为`true`的时候，事件在捕获过程中就会执行。 用代码感受下：

```javascript
<div class="div1" id="div1">
    <div class="div2" id="div2"></div>
</div>

<script>
    var div1 = document.getElementById("div1");
    var div2 = document.getElementById("div2");
    
    div1.addEventListener("click",function () {
        alert("你点击了div1")
    },false);  //false 在冒泡阶段执行

    div2.addEventListener("click",function () {
        alert("你点击了div2")
    },false);
</script>
```


> 当点击子元素 **div2** 的时候，会先弹出 `你点击了div2` 的弹框后，再弹出 `你点击了div1` 的弹框。

如果将**div1**的**addEventListener**方法中的最后的布尔参数值改成true，来看看什么效果：

```javascript
<div class="div1" id="div1">
    <div class="div2" id="div2"></div>
</div>

<script>
    var div1 = document.getElementById("div1");
    var div2 = document.getElementById("div2");
    
    div1.addEventListener("click",function () {
        alert("你点击了div1")
    },true);  //false 在捕获阶段执行

    div2.addEventListener("click",function () {
        alert("你点击了div2")
    },false);
</script>
```

> 当点击子元素 **div2** 的时候，会先弹出 `你点击了div1` 的弹框后，再弹出 `你点击了div2` 的弹框。,和之前的顺序就不一样了。




## 五、非冒泡事件
### scroll

scroll 事件在元素滚动条在滚动时触发。我们假设有如下 html 结构.

```html
<body>
    <div id="container">
        <div id="outer">
            <div id="inner"></div>
        </div>
    </div>
</body>
```

最外层元素的 id 是 container。内部的第一个元素 id 是 outer，outer 的高度要高于 caontainer。outer 内部的元素 id 是 inner，inner 的高度高于 outer。

这样的话，outer 和 container 上就会存在滚动条，也就是这两个元素都是有 scroll 事件的。

![](https://pic2.zhimg.com/v2-b42b5f08a47579d37ad3b77a8e92af51_r.jpg)

我们通过如下代码为 container 和 outer 添加 scroll 监听事件。

```js
document.getElementById('container').addEventListener('scroll',
  function() {console.log('container scroll');},
  false
);
document.getElementById('outer').addEventListener('scroll',
  function() {console.log('outer scroll');},
  false
);
```

注意，这里 addEventListener 的第三个参数是 false，也就是 useCapture 为 false。如果 scroll 事件可以冒泡的话，当触发 outer scroll 的时候，事件就会冒泡到 container，触发 container scroll。

当我们在 inner 区域滚动，实际的效果是。

```js
outer scroll
outer scroll
outer scroll
```

outer 滚动的时候事件并没有冒泡到 container 区域。这说明了 scroll 事件是不会冒泡的。

现在我们换一种方式添加监控。

```js
document.getElementById('container').addEventListener('scroll',
  function() {console.log('container scroll');},
  true
);
document.getElementById('outer').addEventListener('scroll',
  function() {console.log('outer scroll');},
  true
);
```

此时的 useCapture 为 true，同样是在 inner 上向下滚动。控制台显示如下：

```js
container scroll
outer scroll
container scroll
outer scroll
container scroll
outer scroll
```

这符合我们对事件捕获的预期，scroll 事件捕获的方向从 container 到 outer，依次触发回调方法。

scroll 事件的特殊性除了不会进行冒泡这一点外，还有一点，那就是 scroll 事件的无法取消的，使用 stopPropagation 或者是 preventDefault 都无法阻止 scroll 事件，这也很好理解，scroll 连冒泡都没有了，阻止冒泡传播当然也含无意义。。

```js
e.stopPropagation();
e.preventDefault();
```

那如何取消 scroll 事件呢，其实这个问题就是个伪命题，因为先有滚动才有滚动事件。想要阻止滚动，必须在事件发生之前就阻止，我们一般的做法是阻止 wheel 和 touchstart 的默认动作。

```js
document.getElementById("outer").addEventListener("wheel",
    function(e) {e.preventDefault();}
);
```

此时用滚轮操作事件就会失效，outer 区域无法滚动，当然，这种方法并不能禁用滚动条，我们还需要禁用滚动条的拖动事件。

上述的方法是不是很麻烦，所以这种方法我们一般用不到，我们有更常用也更简单的方式，直接修改样式。

```text
overflow：hidden
```

scroll 事件总结

1. scroll 事件不会冒泡，这个带来的影响就是，当我们去做事件委托的时候，其它的大部分事件可以在冒泡阶段的时候完成委托，而 scroll 事件必须在捕获阶段完成委托。
2. scroll 事件无法取消( 没有冒泡的基本都没法取消 )，scroll 回调中的 preventDefault 和 stopPropagation 都是无效的。

### blur & focus

和 scroll 事件一样，focus 和 blue 事件也是无法冒泡，无法取消的。我们为如下文档添加 focus 事件。

```html
<body>
    <div id="container">
        <input id="input" />
    </div>
</body>
document.getElementById('container').addEventListener('focus',
    function() {console.log('container focus');},
    false
);
document.getElementById('input').addEventListener('focus',
    function() {console.log('input focus');},
    false
);
```

点击 input，显然，由于 focus 事件没有冒泡。控制台显示 input focus。

```text
input focus
```

变更参数 useCapture 为 true，点击 input，此时控制台显示 container 和 input 的回调方法 。

```js
document.getElementById('container').addEventListener('focus',
    function() {console.log('container focus');},
    true
);
document.getElementById('input').addEventListener('focus',
    function() {console.log('input focus');},
    true
);
container focus
input focus
```

提到 blur/focus，就会想到和它们很像的两个事件，那就是 focusout/focusin。它们和前者的主要区别就是 focusout/focusin 事件会冒泡。如果同时存在的话，focus 先于 focusin。blur 先于 focusout。

比较可惜的是，focusout/focusin 存在兼容性问题，例如 fireFox 低版本不支持这两个事件。当然，如果我们使用高版本浏览器的话，完全可以替代 blur/focus。

![](https://pic3.zhimg.com/v2-d79fa1420fa9dbf7c483edd3057ef76e_r.jpg)

focus/blur 做事件委托的时候需要注意，在捕获阶段进行监听。否则会导致事件失效。

### Media 事件

由媒介（比如视频、图像和音频）触发的事件，都不冒泡。以下列出部分事件。

```text
...
onpause 当媒介被用户或程序暂停时运行的脚本
onplay  当媒介已就绪可以开始播放时运行的脚本
onplaying 当媒介已开始播放时运行的脚本
onsuspend 在媒介数据完全加载之前不论何种原因终止取回媒介数据时运行
...
```

假设我们有如下 audio 标签。

```html
<body>
    <div id="container">
        <audio id="audio" controls src="just.mp3" ></audio>
    </div>
</body>
```

我们需要监听音频开始播放的事件。由于所有的由媒体触发的事件都不冒泡，所以我们只能在捕获阶段进行事件委托。

```js
document.getElementById('container').addEventListener('play',
    function() {console.log('container play');},
    true
);
document.getElementById('audio').addEventListener('play',
    function() {console.log('audio play');},
    true
);
```

这样在上级元素中就能知道 audio 开始播放了。

```text
container play 
audio play
```

### mouseleave & mouseenter

mouseleave 和 mouseenter 事件同样不会冒泡，当这种不冒泡的特性发生在鼠标事件的时候，显得额外的符合直觉。我们看下例子。

```html
<body>
    <div id="container">
        <div id="outer" >
            <div id="inner" >
        </div>
    </div>
</body>
```

形状大概就是如下这个样子，从外到内越来越小。

```js
_ _ _ _ _ _ _ _ _ _ 
|  inner  |    |    |
|_ _ _ _ _|    |    | 
|  outer       |    |
|_ _ _ _ _ _ _ |    |
|  container        |
|_ _ _ _ _ _ _ _ _ _|
```

我们绑定 mouseleave 事件，然后 我鼠标从 inner 滑动到 outer。

```js
document.getElementById('container').addEventListener('mouseleave',
    function() {console.log('container mouseleave');},
    false
);
document.getElementById('outer').addEventListener('mouseleave',
    function() {console.log('outer mouseleave');},
    false
);
document.getElementById('inner').addEventListener('mouseleave',
    function() {console.log('inner mouseleave');},
    false
);
```

结果只触发了 inner mouseleave 事件，是不是很符合直觉。

与 mouseleave/mouseenter 事件非常相似的事件是 mouseout/mouseover，它们的区别就是 mouseout/mouseover 会触发冒泡，还是这个例子，我们将 mouseleave 换成 mouseout。

```js
document.getElementById('container').addEventListener('mouseout',
    function() {console.log('container mouseout');},
    false
);
document.getElementById('outer').addEventListener('mouseout',
    function() {console.log('outer mouseout');},
    false
);
document.getElementById('inner').addEventListener('mouseout',
    function() {console.log('inner mouseout');},
    false
);
```

然后 鼠标从 inner 滑动到 outer。结果三个事件都触发了。

```js
inner mouseout
outer mouseout
container mouseout
```

在实际写代码的过程中，我们使用 mouseout 和 mouseover 会经常导致一些很奇怪的问题，遇到的时候，希望你能想起来，是事件冒泡搞得鬼。

**JS 事件体系的原理比较容易理解，但是细节会比较繁琐一些，比如本文中罗列的这些事件，它们在做事件委托的时候就是坑，一不注意就会导致事件委托失效。**